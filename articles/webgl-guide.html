<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, user-scalable=no">
<html>
<head>
<link rel=stylesheet href="../style.css?v=4">
<title>Maxime Euzi√®re</title>
</head>
<body class=large>

<div class="wrapper">

<header></header>

<div id=menu></div>

<main>

<style>
table { border-spacing: 0; border-collapse: collapse; width: 100% }
th, td { padding: 5px; width: 200px }
th { background: #eee }
h4 { margin-bottom: 0; }
h1 { font-size: 30px }
h2 { font-size: 24px }
h3 { font-size: 20px }
h4 { font-size: 18px }
h5 { font-size: 14px }
ul { padding-left: 15px }
pre { margin: 3px; font-size: 12px; }
.math { margin: 15px 0 }
iframe { max-height: 90vh }
.ch10 { border: 1px solid #000 }
.ch10 * { border: none }
.ch10 td { max-width: 430px; width: auto; vertical-align: top }
.ch10 td + td { max-width: 450px; }

</style>

<div class=section id=webgl_guide>
<h2>WebGL guide</h2>
<h3>october 2019 - february 2020</h3>
  
<h4>Introduction</h4>

<p>This page summarizes the book <a href="https://www.oreilly.com/library/view/webgl-programming-guide/9780133364903/ch01.html">WebGL Programming Guide</a> and other resources like <a href="https://webgl2fundamentals.org/">Webgl2Fundamentals.org</a> with my own tiny, simplified, editable demos. 
<p>The playground (used for the demos present in this page) is available <a href="https://xem.github.io/webgl-guide/visualizer/#PGNhbnZhcyBpZD0iY2FudmFzIiB3aWR0aD00MDAgaGVpZ2h0PTQwMD48L2NhbnZhcz4KPHNjcmlwdD4KLy8gR2V0IHRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dAovLyBUaGUgWCBhbmQgWSBjb29yZGluYXRlcyBhcmUgZGVmaW5lZCBiZXR3ZWVuIC0xLjAgYW5kIDEuMAp2YXIgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgid2ViZ2wiKTsKCi8vIFZlcnRleCBzaGFkZXI6Ci8vIERlc2NyaWJlcyB0aGUgYXR0cmlidXRlcyBvZiBwb2ludHMgaW4gc3BhY2VzIChwb3NpdGlvbiwgc2l6ZSwgLi4uKQovLyAtIGdsX1Bvc2l0aW9uOiB2ZWM0KHgsIHksIHosIDEuMCkKLy8gLSBnbF9Qb2ludFNpemUgZmxvYXQKdmFyIHZzaGFkZXIgPSBgCnZvaWQgbWFpbigpIHsKICBnbF9Qb3NpdGlvbiA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTsKICBnbF9Qb2ludFNpemUgPSAxMC4wOwp9YDsKCi8vIEZyYWdtZW50IHNoYWRlcjoKLy8gRGVzY3JpYmVzIGhvdyBlYWNoIHBpeGVsIGlzIHJlbmRlcmVkIChjb2xvciwgbGlnaHRpbmcsIC4uLikKLy8gLSBnbF9mcmFnQ29sb3I6IHZlYzQociwgZywgYiwgYWxwaGEpCnZhciBmc2hhZGVyID0gYApwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKdm9pZCBtYWluKCkgewogIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKTsKfWA7CgovLyBNYWtlIGEgcHJvZ3JhbSBmcm9tIHRoZXNlIHNoYWRlcnMgYW5kIHVzZSBpdCAKdmFyIHZzID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpOwpnbC5zaGFkZXJTb3VyY2UodnMsIHZzaGFkZXIpOwpnbC5jb21waWxlU2hhZGVyKHZzKTsKCnZhciBmcyA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpOwpnbC5zaGFkZXJTb3VyY2UoZnMsIGZzaGFkZXIpOwpnbC5jb21waWxlU2hhZGVyKGZzKTsKCnZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpOwpnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdnMpOwpnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnMpOwpnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTsKZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTsKCi8vIENsZWFyIHRoZSBjYW52YXMncyBjb2xvciBidWZmZXIsIGluIGJsYWNrCmdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMS4wKTsKZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7CgovLyBEcmF3IHBvaW50cyBvbiB0aGUgY2FudmFzJ3MgY29sb3IgYnVmZmVyCmdsLmRyYXdBcnJheXMoCiAgZ2wuUE9JTlRTLCAvLyBtb2RlCiAgMCwgICAgICAgICAvLyBzdGFydGluZyBwb2ludAogIDEsICAgICAgICAgLy8gbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3Cik7Cjwvc2NyaXB0Pg==">here</a> and all the code is available <a href="https://github.com/xem/webgl-guide">on Github</a>.
<p>Helper files created while making this: <a href="https://github.com/xem/webgl-guide/blob/gh-pages/me/webgl.js">webgl.js</a>, <a href="https://github.com/xem/webgl-guide/blob/gh-pages/me/matrix.js">matrix.js</a> and <a href="https://github.com/xem/webgl-guide/blob/gh-pages/me/shapes.js">shapes.js</a>.
<p>If you're interested in Shadertoy, WebGL raymarching and signed distance functions, check out <a href="webgl_quest.html">Webgl quest</a> and <a href="webgl_quest_2.html">Webgl quest 2</a>.

<br><br><hr><br>
<h2>2D graphics</h2>
<br>
<h4>How to draw points</h4>
<i>(from chapter 2 of the book)</i>

<ul>
<li>A vertex is a point in 3D space (coordinates: X, Y, Z)
<li>A fragment is where the scene is rendered (the pixels on your screen)
<li>In a WebGL app, two programs (vertex shader and fragment shader) are written in HLSL language and controlled by JS to render a scene on a canvas
<li>The vertex shader is executed for every vertex, and sets the variable <b>gl_Position</b> (and gl_PointSize, if we want to draw points)
<li>The fragment shader is executed for every fragment, and sets the variable <b>gl_FragColor</b>
<li>The X and Y coordinates in a WebGL canvas context go from -1 to 1, whatever the size of the canvas
<br><img src="images/webgl-guide/webgl.png">
<li>In HLSL, a float is a number written with at least one decimal (ex: 0.0, 0.1, 1.0, ...)
<li>A vec4 is an array of 4 floats representing either vertex coordinates (x, y, z, 1.0), a color (r, g, b, alpha), or anything you want. (vec2 and vec3 exist too)
<li>A mat4 is a matrix (a grid) of 4 x 4 floats. (mat2 and mat3 exist too)
</ul>

<p>Here's the simplest possible WebGL program, drawing a red point in the middle of the canvas.
<br>
<br>
<iframe id=i1 height=820 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?url=1-hello%20point.html&id=i1"></iframe>

<p>The program compilation is always the same, so I've put it in a compile() function that will be used in the next chapters (see webgl.js):

<pre style="font-size:11px"><code class="lang-js">// Compile a WebGL program from a vertex shader and a fragment shader
compile = (gl, vshader, fshader) => {
  
  var vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, vshader);
  gl.compileShader(vs);
  
  var fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, fshader);
  gl.compileShader(fs);
  
  var program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  gl.useProgram(program);
  
  console.log('vertex shader:', gl.getShaderInfoLog(vs) || 'OK');
  console.log('fragment shader:', gl.getShaderInfoLog(fs) || 'OK');
  console.log('program:', gl.getProgramInfoLog(program) || 'OK');
  
  return program;
}</code>
</pre>



<br><br><hr><br>

<h4>Attributes and uniforms</h4>

<ul>
<li>Of course, WebGL is not just for drawing hardcoded points. There are many ways to send it custom values: attributes, uniforms, and buffer objects (we'll see them later)
<li>An attribute is a global variable passed by JS to the vertex shader. Its value can change for each vertex (ex: vertex coordinates)
<li>An uniform is a global variable passed by JS to all the shaders. Its value is constant for an entire draw call (ex: a color)
<li>For the record, some browsers (like Safari) can only draw points that are set by JS, and can't run the previous demo at all
</ul>
<p>


<table border style="table-layout:auto">
<tr>
<th style="max-width:50px">Qualifier<th style="max-width:50px">Type<th>GLSL<th style="width:55%">How to set its value in JS

<tr>
<td rowspan=2>attribute
<td>float
<td><pre>attribute float f;</pre>
<td><pre>gl.vertexAttrib1f(gl.getAttribLocation(program, 'f'), 1.0);</pre>

<tr>
<td>vec4
<td><pre>attribute vec4 v;</pre>
<td><pre>gl.vertexAttrib4f(gl.getAttribLocation(program, 'f'), 1.0, 2.0, 3.0, 4.0);
// or
gl.vertexAttrib4fv(gl.getAttribLocation(program, 'f'), [1.0, 2.0, 3.0, 4.0]);</pre>

<tr>
<td rowspan=4>uniform

<td>int
<td><pre>uniform int i;</pre>
<td><pre>gl.uniform1i(gl.getUniformLocation(program, 'f'), 1);</pre>

<tr>
<td>float
<td><pre>uniform float f;</pre>
<td><pre>gl.uniform1f(gl.getUniformLocation(program, 'f'), 1.0);</pre>

<tr>
<td>vec4
<td><pre>uniform vec4 v;</pre>
<td><pre>gl.uniform4f(gl.getUniformLocation(program, 'f'), 1.0, 2.0, 3.0, 4.0);
// or
gl.uniform4fv(gl.getUniformLocation(program, 'f'), [1.0, 2.0, 3.0, 4.0]);</pre>

<tr>
<td>mat4
<td><pre>uniform mat4 m;</pre>
<td><pre>gl.uniformMatrix4fv(
  gl.getUniformLocation(program, 'm'), false, new Float32Array([...])
);</pre>

</table>
<br>
<p>Here's the same demo as before, but the position, size and color of the point are now set by the JS code.
<br>
<br>
<iframe id=i2 loading=lazy height=700 src="https://xem.github.io/webgl-guide/visualizer/?url=2-point%20defined%20with%20js.html&id=i2"></iframe>

<p>The next demo shows how to add a new point with a different color every time the canvas is clicked.
<br>After each click, the only things to do are: reset canvas, set the attributes/uniforms, and call drawArrays.
<br>
<br>
<iframe id=i3 loading=lazy height=1050 src="https://xem.github.io/webgl-guide/visualizer/?url=3-points added on click.html&id=i3"></iframe>

<br><br><hr><br>

<h4>How to draw lines and triangles</h4>
<i>(from chapter 3 of the book)</i>

<ul>
<li>An array buffer can be used to pass binary data from JS to the shaders (ex: a list of vertices, a list of colors, ...)
<li>This buffer is always read as a list of numbers, formatted as one of these types:
<br>
<br>
<table border>
<tr>
<th>Name
<th>JS container
<th>WebGL type
<tr>
<td>Unsigned byte
<td>Uint8Array
<td>gl.UNSIGNED_BYTE

<tr>
<td>Signed short integer
<td>Int16Array
<td>gl.SHORT

<tr>
<td>Unsigned short integer
<td>Uint16Array
<td>gl.UNSIGNED_SHORT

<tr>
<td>Signed integer
<td>Int32Array
<td>gl.INT

<tr>
<td>Unsigned integer
<td>Uint32Array
<td>gl.UNSIGNED_INT

<tr>
<td>Floating point number
<td>Float32Array
<td>gl.FLOAT
</table>
<br>
<li>drawArrays can render points, lines and triangles in 7 different ways:
<br>
<br>
<img src="images/webgl-guide/modes.png" width=800 style="border:2px solid #ddd">
</ul>

<p>Here's the simplest way to draw a triangle. You can edit the mode on line 53 to render points or lines instead of a triangle (ex: gl.POINTS / gl.LINE_LOOP)
<br>
<br>
<iframe id=i4 loading=lazy height=850 src="https://xem.github.io/webgl-guide/visualizer/?url=4-hello triangle.html&id=i4"></iframe>

<p>The "basic" array buffer setup is always the same, so I included it in webgl.js:
<pre style="font-size:11px"><code class="lang-js">// Bind an array buffer to an attribute and enable it
arraybuffer = (gl, data, program, attribute, size, type) => {
  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  var a = gl.getAttribLocation(program, attribute);
  gl.vertexAttribPointer(a, size, type, false, 0, 0);
  gl.enableVertexAttribArray(a);
}</code>
</pre>

<br><br><hr><br>

<h4>Translate, rotate, scale</h4>
<i>(from chapters 3 & 4 of the book)</i>

<ul>
<li>Vertices coordinates are represented on vec4's (x, y, z, 1.0) to ease matrix-based transformations. They're called homogeneous coordinates

<p>

<table border>
<tr>
<th>Transformation
<th>Transformation applied to each vertex coordinates
<th>transformation via a matrix

<tr>
<td>Identity (no change)
<td>x' = x
<br>y' = y
<br>z' = z
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;=&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;√ó&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>


<tr>
<td>Translation along X, Y and Z axis
<td>x' = x + Tx
<br>y' = y + Ty
<br>z' = z + Tz
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;=&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Tx</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Ty</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>Tz</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;√ó&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Rotation around X with an angle œÜ (in radians)
<td>x' = x
<br>y' = y cos œÜ - z sin œÜ
<br>z' = y sin œÜ + z cos œÜ
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;=&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>cos œÜ</mn></mtd>
            <mtd><mn>-sin œÜ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>sin œÜ</mn></mtd>
            <mtd><mn>cos œÜ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;√ó&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Rotation around Y with an angle Œ∏
<td>x' = x cos Œ∏ + z sin Œ∏
<br>y' = y
<br>z' = -x sin Œ∏ + z cos Œ∏
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;=&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>cos Œ∏</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>sin Œ∏</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>-sin Œ∏</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>cos Œ∏</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;√ó&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Rotation around Z axis with an angle œà
<td>x' = x cos œà ‚Äì y sin œà
<br>y' = x sin œà + y cos œà
<br>z' = z
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;=&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>cos œà</mn></mtd>
            <mtd><mn>-sin œà</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>sin œà</mn></mtd>
            <mtd><mn>cos œà</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;√ó&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Scaling along X, Y and Z axis
<td>x' = Sx * x
<br>y' = Sy * y
<br>z' = Sz * z
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;=&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>Sx</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Sy</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Sz</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
      &nbsp;√ó&nbsp;
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

</table>

<li>Multiple transformations can be accumulated by multiplying their matrices
<li>To translate then rotate a point, multiply in this order: (‚å© rotation matrix ‚å™ √ó ‚å© translation matrix ‚å™) √ó ‚å© original coordinates ‚å™
<li>Matrices and vectors can be multiplied together natively in GLSL. In JS, each term must be computed separately
<br>
<br>
<iframe id=i5 loading=lazy height=1220 src="https://xem.github.io/webgl-guide/visualizer/?url=5-transformed triangle.html&id=i5"></iframe>

<p>Note: in this example, the transformation matrix (translation x rotation x scale) is computed in the fragment shader.
<br>This is easy to code, but it's not efficient in real conditions, as the computation is performed for every fragment of the program.
<br>In the next examples, it will be computed once (in JS) and passed to the shader.
</ul>

<p>Functions added in matrix.js:
<pre style="font-size:11px"><code class="lang-js">// Create an identity mat4
identity = () => {
  return new Float32Array([
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
  ]);
};

// Compute the multiplication of two mat4
multMat4Mat4 = (a, b) => {
  var i, e, a, b, ai0, ai1, ai2, ai3;
  var c = new Float32Array(16);
  for (i = 0; i &lt; 4; i++) {
    ai0 = a[i];
    ai1 = a[i+4];
    ai2 = a[i+8];
    ai3 = a[i+12];
    c[i]    = ai0 * b[0]  + ai1 * b[1]  + ai2 * b[2]  + ai3 * b[3];
    c[i+4]  = ai0 * b[4]  + ai1 * b[5]  + ai2 * b[6]  + ai3 * b[7];
    c[i+8]  = ai0 * b[8]  + ai1 * b[9]  + ai2 * b[10] + ai3 * b[11];
    c[i+12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
  }
  return c;
};

// Transform a mat4
// options: x/y/z (translate), rx/ry/rz (rotate), sx/sy/sz (scale)
transform = (mat, options) => {
  
  var out = new Float32Array(mat);
  
  var x = options.x || 0;
  var y = options.y || 0;
  var z = options.z || 0;
  
  var sx = options.sx || 1;
  var sy = options.sy || 1;
  var sz = options.sz || 1;
  
  var rx = options.rx;
  var ry = options.ry;
  var rz = options.rz;
  
  // translate
  if(x || y || z){
    out[12] += out[0] * x + out[4] * y + out[8]  * z;
    out[13] += out[1] * x + out[5] * y + out[9]  * z;
    out[14] += out[2] * x + out[6] * y + out[10] * z;
    out[15] += out[3] * x + out[7] * y + out[11] * z;
  }
  
  // Rotate
  if(rx) out.set(multMat4Mat4(out, new Float32Array([1, 0, 0, 0, 0, Math.cos(rx), Math.sin(rx), 0, 0, -Math.sin(rx), Math.cos(rx), 0, 0, 0, 0, 1])));
  if(ry) out.set(multMat4Mat4(out, new Float32Array([Math.cos(ry), 0, -Math.sin(ry), 0, 0, 1, 0, 0, Math.sin(ry), 0, Math.cos(ry), 0, 0, 0, 0, 1])));
  if(rz) out.set(multMat4Mat4(out, new Float32Array([Math.cos(rz), Math.sin(rz), 0, 0, -Math.sin(rz), Math.cos(rz), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])));
  
  // Scale
  if(sx !== 1){
    out[0] *= sx;  
    out[1] *= sx;
    out[2] *= sx;
    out[3] *= sx;
  }
  if(sy !== 1){
    out[4] *= sy;
    out[5] *= sy;
    out[6] *= sy;
    out[7] *= sy;
  }
  if(sz !== 1){
    out[8] *= sz;
    out[9] *= sz;
    out[10] *= sz;
    out[11] *= sz;
  }
  
  return out;
};</code>
</pre>


<br><br><hr><br>

<h4>Multi-attribute buffer and varying color</h4>
<i>(from chapter 5 of the book)</i>

<p><ul><li>A single array buffer can hold interleaved data, for example X/Y/R/G/B values, recurring every 5 floats
<li>A varying is a global variable writable by the vertex shader and readable by the fragment shader
<li>Every fragment (pixel) inside the triangle, if it's bound to a varying color variable, will be interpolated from the color of each vertex around it
</ul>
<iframe id=i6 loading=lazy height=970 src="https://xem.github.io/webgl-guide/visualizer/?url=6-multi attribute and varying.html&id=i6"></iframe>

<br><br><hr><br>

<h4>Texturing</h4>
<i>(from chapter 5 of the book)</i>

<ul>
<li>Fragment interpolation can be done on a set of colors, but also on a texture image (it's called sampling in this case)
<li>Any texture (square or rectangle) has a local coordinates system (U,V) that goes from 0 to 1, and every associated vertex will have texture coordinates in this system
<li>An Image object can be bound to an <b>uniform sampler2D</b> to create a texture, which is applied to the current fragment using <b>gl_FragColor = texture2D(sampler,coord);</b>
<li>The "pixels" of the texture are called texels
<br><img src="images/webgl-guide/texture.png">
</ul>

<p>Here's an example of textured quad (a square made of two triangles). Play with the numbers to change the way the vertices and texture are mapped:
<p>
<iframe id=i7 loading=lazy height=1250 src="https://xem.github.io/webgl-guide/visualizer/?url=7-texture.html&id=i7"></iframe>

<p>Similarly, multiple textures can be used at once. For example, initialize two samplers, and multiply them in the fragment shader (<a href="https://xem.github.io/webgl-guide/book/ch05/MultiTexture.html">DEMO</a>)
<pre class="language-js"><code>vec4 color0 = texture2D(sampler0, v_TexCoord);
vec4 color1 = texture2D(sampler1, v_TexCoord);
gl_FragColor = color0 * color1;</code></pre>

<br><br><hr><br>

<h2>3D graphics</h2>
<br>
<h4>3D camera</h4>
<i>(from chapter 7 of the book)</i>
<ul>
<li>In WebGL (and 3D graphics in general), the "camera" is abstract: its position, angle and perspective are defined by a matrix
<li>On render, every vertex in the scene is multiplied by this matrix to simulate these camera properties
<li>First, the camera's perspective (including field of view, aspect ratio, near clip plane and far clip plane) can be set with:

<div class=math>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1/(aspect*tan(fov/2))</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1/tan(fov/2)</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-(far+near)/(far-near)</mn></mtd>
            <mtd><mn>-(2*far*near)/far-near</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
</div>

<li>Then, the camera can be translated, rotated and scaled (zoomed) by multiplying the corresponding matrices (see "Translate, rotate, scale" above)
<li>A LookAt() function is often used by developers to set the camera's position, angle and target all at once.
<li>I added the perspective and lookAt functions in matrix.js:

<pre><code class="lang-js">// Set perspective
// options: fovy, aspect, near, far
perspective = (mat, options) => {
  var fovy = options.fovy || 1.5;
  var aspect = options.ratio || 1;
  var near = options.near || 1;
  var far = options.far || 100;
  var s = Math.sin(fovy);
  var rd = 1 / (far - near);
  var ct = Math.cos(fovy) / s;
  mat.set([
    ct / aspect, 0, 0, 0, 
    0, ct, 0, 0, 
    0, 0, -(far + near) * rd, -1,
    0, 0, -2 * near * far * rd, 0
  ]);
}


// LookAt
lookat = (mat, eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) => {
  var e, fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;
  fx = centerX - eyeX;
  fy = centerY - eyeY;
  fz = centerZ - eyeZ;
  rlf = 1 / Math.sqrt(fx*fx + fy*fy + fz*fz);
  fx *= rlf;
  fy *= rlf;
  fz *= rlf;
  sx = fy * upZ - fz * upY;
  sy = fz * upX - fx * upZ;
  sz = fx * upY - fy * upX;
  rls = 1 / Math.sqrt(sx*sx + sy*sy + sz*sz);
  sx *= rls;
  sy *= rls;
  sz *= rls;
  ux = sy * fz - sz * fy;
  uy = sz * fx - sx * fz;
  uz = sx * fy - sy * fx;
  var l = new Float32Array(
    sx, ux, -fx, 0,
    sy, uy, -fy, 0,
    sz, uz, -fz, 0,
    0,  0,  0,   1
  );
  l = transform(l, {x: -eyeX, y: -eyeY, z: -eyeZ});
  return multMat4Mat4(mat, l); 
}</code>
</pre>

</ul>

<br><br><hr><br>

<h3>Hello cube</h3>
<i>(from chapter 7 of the book)</i>

<ul>
<li>As seen before, buffer objects with the type gl.ARRAY_BUFFER can hold vertex properties (position, color)
<li>Though, in 3D models, vertices are often shared between multiple triangles
<li>Instead of repeating the same vertices many times, we can write each vertex once, and use another buffer object with the type <b>gl.ELEMENT_ARRAY_BUFFER</b> that makes triangles simply by using indices of the first object
<li>The indices have small integer values, so we represent them with a Uint8Array. For more than 256 vertices, use Uint16Array. For more than 65536 vertices, use Uint32Array
<li>In 3D, depth-sorting must be enabled with <b>gl.enable(gl.DEPTH_TEST);</b> and the screen is cleaned with <b>gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</b>
<li>Also, gl.drawArrays is replaced with <b>gl.drawElements(type, count, type, offset)</b>. For 8-bits indices, use the type gl.UNSIGNED_BYTE. For 16-bits, use gl.UNSIGNED_SHORT. For 32-bits, use gl.UNSIGNED_INT
<li>In WebGL 1.0, an extension must be enabled before using the type UNSIGNED_INT: <b>gl.getExtension('OES_element_index_uint');</b>. In WebGL 2.0, it's enabled by default
</ul>

<iframe id=i8 loading=lazy height=1620 src="https://xem.github.io/webgl-guide/visualizer/?url=8-cube.html&id=i8"></iframe>

<br><br><hr><br>

<h3>Color each face of the cube</h3>

<ul>
<li>In this case, each vertex doesn't have a single color: it has a different color depending on which face is rendered
<li>Thus, we need to declare the vertices of each face separately in an array buffer, then the colors of each vertex of each face in another array buffer, and finally, use an index buffer that references both vertices and colors
</ul>

<iframe id=i9 loading=lazy height=1400 src="https://xem.github.io/webgl-guide/visualizer/?url=9-cube faces.html&id=i9"></iframe>

<p>I've added the cube declaration in the cube() function of shapes.js to avoid repeating it in the next demos

<br><br><hr><br>

<h4>Lighting and shading</h4>

<i>(from chapter 8 of the book)</i>

<ul>
<li>First, we can make <b>diffuse light reflexion</b>, where the light is reflected equally in all directions when it hits a face of the cube
<li>To do that, we need to define a light with a color (for example, white), and a direction (for example, vec3(0.5, 3.0, 4.0))
<li>Each face has <b>normal</b>: a vec3 pointing to the outside of the cube, with a length of 1, i.e. "normalized"
<li>In the fragment shader, we perform a <b>dot product</b> between the light vector and the face normal, to determine how much the light is diffused
<br><blockquote class="twitter-tweet"><p lang="en" dir="ltr">dot product - visualized ‚ö™<br><br>the dot of two normalized vectors, as shown here, can say how similar they are<br><br>a ‚Ä¢ b = 1, same direction<br>a ‚Ä¢ b = 0, perpendicular<br>a ‚Ä¢ b = -1, opposite directions<br><br>you might also be able to see why it&#39;s sometimes called scalar projection~ <a href="https://t.co/vg8TwNZ8qs">pic.twitter.com/vg8TwNZ8qs</a></p>&mdash; Freya Holm√©r (@FreyaHolmer) <a href="https://twitter.com/FreyaHolmer/status/1200807790580768768?ref_src=twsrc%5Etfw">November 30, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
<li>If the dot product is negative, we set it to "0" (there can't be a negative amount of light). This is done with <b>max(dot(light, normal), 0.0);</b>
<li>The color sent to the fragment shader is: the light's color (rgb) √ó the face color (rgb) √ó the dot product of the normal and the light, and the color's alpha is set to 1.0
<li>In HLSL, the composants of a vec4 can be accessed with .x/y/z/t (if it's a position) or .r/g/b/a (if it's a color). Composants can be composed too (ex: <b>vec3 rgb = col.rgb</b>)
</ul>

<iframe id=i10 loading=lazy height=1230 src="https://xem.github.io/webgl-guide/visualizer/?url=10-diffuse lighting.html&id=i10"></iframe>

<p>With diffuse lighting alone, some faces are too dark, like the rightmost one here. To fix that, we can add an <b>ambient light</b> (added equally to every vertex's color):
<br>
<br>
<iframe id=i11 loading=lazy height=1330 src="https://xem.github.io/webgl-guide/visualizer/?url=11-diffuse ambient lighting.html&id=i11"></iframe>

<h5>A few words about smooth shading</h5>

<p>With diffuse and ambient lights alone, each face gets a flat color. It's called polygonal or facetted rendering, and isn't realistic (it's great for retro-looking games though)  
<p>For a better result, many techniques can be used.
<ul>
<li>The first thing to do is to use a <b>point light</b> representing the sun or a light bulb, with a specific position and color
<li>With such a point light in the scene, the shading will be able to vary according to the distance between each point of the cube and the point light
<li>Let's see how it looks when it's computed per vertex (see the book's demos: <a href="https://xem.github.io/webgl-guide/book/ch08/PointLightedCube.html">cube</a> / <a href="https://xem.github.io/webgl-guide/book/ch08/PointLightedSphere.html">sphere</a>):
<br>
<br><img src="images/webgl-guide/per_vertex.png" width=500>
<br>
<br>It looks a bit nicer but still not super smooth due to the imprecise color interpolation between vertices
<li>A better solution consists in computing the right color for every fragment of the cube (i.e. every pixel),<br>and that's exactly what the fragment shader is here for! (see the book's demos: <a href="https://xem.github.io/webgl-guide/visualizer/?url=12-point">cube</a> / <a href="http://xem.github.io/webgl-guide/book/ch08/PointLightedSphere_perFragment.html">sphere</a>)
<br><br><img src="images/webgl-guide/sphere.png" width=500>
<br>
<br>
The detailed source code:
<iframe id=i12 loading=lazy height=1530 src="https://xem.github.io/webgl-guide/visualizer/?url=12-point light per fragment.html&id=i12"></iframe>
<li>On top of that, enabling "smooth shading" in 3D softwares consists in computing a different normal for each vertex, averaged from the normals/areas of its neighbour faces
<br>Vertex normals are usually computed and exported by 3D softwares like Blender, but if they're missing, <a href="https://www.iquilezles.org/www/articles/normals/normals.htm">an elegant algorithm exists to compute them</a>!
<br>Example: a dodecahedron with the right vertex normals
<br><br><img src="images/webgl-guide/dode.png" width=300>
</ul>
<br>
<h5>Other types of lighting</h5>
<ul>
<li>Emissive lighting: when an object is self-illuminated - this can be easy if you just want to make the fragments lighter (multiply the color with a value higher than 1), or very complicated if you want the surface to illuminate surrounding objects (this will not be covered here :p )
<li>Specular lighting: when an object is more or less shiny, it can reflect a point light like a mirror under a certain angle (more info <a href="https://webgl2fundamentals.org/webgl/lessons/webgl-3d-lighting-point.html">here</a>)
<br>The idea is to compute the half-vector between the camera, the fragment and the light, and compare this with the surface normal using a dot product
<br><img src="images/webgl-guide/specular.png">

<pre><code class=lang-js>var fshader = `
(...)
float shininess = 150.0;
vec3 surfaceWorldPosition = (u_world * a_position).xyz;
vec3 v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;
vec3 v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;
vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
vec3 surfaceToCameraDirection = normalize(v_surfaceToCamera);
vec3 halfVector = normalize(surfaceToLightDirection + surfaceToCameraDirection);
float light = dot(normal, surfaceToLightDirection);
# the pow is to avoid having specular reflection that's too shiny
float specular = pow(dot(normal, halfVector), shininess);
color.rgb *= light * lightColor;
color.rgb += specular * specularLightColor;
(...)
`;</code></pre>

<h5>Lighting and coloring are the same</h5>

<p>You may find documents talking about ambient/diffuse/specular colors. It's the same thing as ambient/diffuse/specular lighting
<br>And it makes sense: in CG, like in the real world, the colors emitted by an object depend entirely on its lighting

<h5>Lighting and shading are not the same</h5>
<p>The two terms are often mixed but lighting is really a physics notion (how the light affects an object) while shading is purely CG-related (how a pixel is rendered) 
<br><br><hr><br>

<h4>Transforming the shaded cube</h4>

<ul>
<li>So far, we've only transformed the camera matrix, to make it revolve around the cube
<li>Due to the lack of light or other cubes in the scene, it was equivalent to having the cube rotate on itself
<li>Now that we have a fixed point light in the scene, if we want to rotate, translate or scale the cube, we need to do two things:<br>- introduce a <b>model matrix</b> (the transformation matrix of the cube),<br>- recompute the 6 cube's normals and the lighting of every fragment when the model matrix is updated
<li>Computing a face normal from scratch can be done using a cross-product of two face vectors respecting the right hand rule (AB √ó BC if the points A, B and C are arranged counterclockwise)
<p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">cross product - visualized ‚öî<br><br>the cross product A √ó B is a super useful way to take two 3D vectors, and get a third vector *perpendicular to both*, shown in blue (with its length shown in gray)! <a href="https://t.co/d3NZoLEUtq">pic.twitter.com/d3NZoLEUtq</a></p>&mdash; Freya Holm√©r (@FreyaHolmer) <a href="https://twitter.com/FreyaHolmer/status/1203059678705602562?ref_src=twsrc%5Etfw">December 6, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<li>Though, it's simpler to only compute the normals once, on load, and pass them to the vertex shader, along with the vertex position and the face color
<br>
Then, when the model matrix changes, the trick is compute its inverse transpose (in JS) and pass it to the vertex shader
<br>
In the vertex shader, the original normal just needs to be multiplied by this matrix to obtain its new value: <b>vec3 newNormal = oldNormal * inverseTranspose</b>
<li>Here are the functions I added in matrix.js to compute the inverse transpose:

<pre><code class="lang-js">// Get the transposed of a mat4
transpose = m => {
  return new Float32Array([
    m[0], m[4], m[8],  m[12],
    m[1], m[5], m[9],  m[13],
    m[2], m[6], m[10], m[14],
    m[3], m[7], m[11], m[15]
  ]);
};

// Get the inverse of a mat4
// The mat4 is not modified, a new mat4 is returned
inverse = m => {
  var inv = new Float32Array([
     m[5]*m[10]*m[15] - m[5]*m[11]*m[14] - m[9]*m[6]*m[15] + m[9]*m[7]*m[14] + m[13]*m[6]*m[11] - m[13]*m[7]*m[10],
    -m[1]*m[10]*m[15] + m[1]*m[11]*m[14] + m[9]*m[2]*m[15] - m[9]*m[3]*m[14] - m[13]*m[2]*m[11] + m[13]*m[3]*m[10],
     m[1]*m[6]*m[15]  - m[1]*m[7]*m[14]  - m[5]*m[2]*m[15] + m[5]*m[3]*m[14] + m[13]*m[2]*m[7]  - m[13]*m[3]*m[6],
    -m[1]*m[6]*m[11]  + m[1]*m[7]*m[10]  + m[5]*m[2]*m[11] - m[5]*m[3]*m[10] - m[9]*m[2]*m[7]   + m[9]*m[3]*m[6],
    -m[4]*m[10]*m[15] + m[4]*m[11]*m[14] + m[8]*m[6]*m[15] - m[8]*m[7]*m[14] - m[12]*m[6]*m[11] + m[12]*m[7]*m[10],
     m[0]*m[10]*m[15] - m[0]*m[11]*m[14] - m[8]*m[2]*m[15] + m[8]*m[3]*m[14] + m[12]*m[2]*m[11] - m[12]*m[3]*m[10],
    -m[0]*m[6]*m[15]  + m[0]*m[7]*m[14]  + m[4]*m[2]*m[15] - m[4]*m[3]*m[14] - m[12]*m[2]*m[7]  + m[12]*m[3]*m[6],
     m[0]*m[6]*m[11]  - m[0]*m[7]*m[10]  - m[4]*m[2]*m[11] + m[4]*m[3]*m[10] + m[8]*m[2]*m[7]   - m[8]*m[3]*m[6],
     m[4]*m[9]*m[15]  - m[4]*m[11]*m[13] - m[8]*m[5]*m[15] + m[8]*m[7]*m[13] + m[12]*m[5]*m[11] - m[12]*m[7]*m[9],
    -m[0]*m[9]*m[15]  + m[0]*m[11]*m[13] + m[8]*m[1]*m[15] - m[8]*m[3]*m[13] - m[12]*m[1]*m[11] + m[12]*m[3]*m[9],
     m[0]*m[5]*m[15]  - m[0]*m[7]*m[13]  - m[4]*m[1]*m[15] + m[4]*m[3]*m[13] + m[12]*m[1]*m[7]  - m[12]*m[3]*m[5],
    -m[0]*m[5]*m[11]  + m[0]*m[7]*m[9]   + m[4]*m[1]*m[11] - m[4]*m[3]*m[9]  - m[8]*m[1]*m[7]   + m[8]*m[3]*m[5],
    -m[4]*m[9]*m[14]  + m[4]*m[10]*m[13] + m[8]*m[5]*m[14] - m[8]*m[6]*m[13] - m[12]*m[5]*m[10] + m[12]*m[6]*m[9],
     m[0]*m[9]*m[14]  - m[0]*m[10]*m[13] - m[8]*m[1]*m[14] + m[8]*m[2]*m[13] + m[12]*m[1]*m[10] - m[12]*m[2]*m[9],
    -m[0]*m[5]*m[14]  + m[0]*m[6]*m[13]  + m[4]*m[1]*m[14] - m[4]*m[2]*m[13] - m[12]*m[1]*m[6]  + m[12]*m[2]*m[5],
     m[0]*m[5]*m[10]  - m[0]*m[6]*m[9]   - m[4]*m[1]*m[10] + m[4]*m[2]*m[9]  + m[8]*m[1]*m[6]   - m[8]*m[2]*m[5]
  ]);
  det = m[0]*inv[0] + m[1]*inv[4] + m[2]*inv[8] + m[3]*inv[12];
  if(!det) return m;
  det = 1 / det;
  for(var i = 0; i < 16; i++) {
    inv[i] *= det;
  }
  return inv;
};</code></pre>

<li>We also pass a "mvp" (model view projection) matrix to the vertex shader, which is the multiplication of the camera matrix and the model matrix
</ul>

<p>Here's a cube rotating on itself with a fixed camera and a fixed point light:
<br>
<br>

<iframe id=i13 loading=lazy height=1950 src="https://xem.github.io/webgl-guide/visualizer/?url=13-inverse transpose.html&id=i13"></iframe>

<p>Note: if the model matrix is only a rotation or an uniform scaling, the inverse transpose matrix will be equal to the model matrix. But in any other transformation or combination of transformations, it will have a specific value that will let the shader compute the new normals with a simple multiplication (more info <a href="https://stackoverflow.com/questions/13654401/why-transforming-normals-with-the-transpose-of-the-inverse-of-the-modelview-matr">here</a>)


<br><br><hr><br>

<h4>Drawing many cubes</h4>

<ul>
<li>Of course, it's possible to declare the vertices coordinates, colors and normals of each cube, but that would be very verbose
<li>Instead, we can consider the cube we already declared at the center of the scene as a model
<li>For each cube we want to draw, we simply need to transform this model (by setting the model matrix, mvp matrix and inverse transpose matrix) and render it
</ul>

<br><p>Here's a demo with 3 red cuboids (deformed cubes)
<br><br>
<iframe id=i14 loading=lazy height=2490 src="https://xem.github.io/webgl-guide/visualizer/?url=14-many cubes.html&id=i14"></iframe>

<p>To avoid repetitions, I added a drawShape function in shapes.js, with optional scaling along X/Y/Z:

<pre><code class="lang-js">// Draw the current shape
drawShape = (gl, program, cameraMatrix, modelMatrix, sx = 1, sy = 1, sz = 1) => {
  
  // Set the model matrix (add the custom scale if any)
  var model = gl.getUniformLocation(program, 'model');
  modelMatrix = transform(modelMatrix, {sx, sy, sz});
  gl.uniformMatrix4fv(model, false, modelMatrix);

  // Set the cube's mvp matrix (camera x model)
  var mvpMatrix = multMat4Mat4(cameraMatrix, modelMatrix);
  var mvp = gl.getUniformLocation(program, 'mvp');
  gl.uniformMatrix4fv(mvp, false, mvpMatrix);

  // Set the inverse transpose of the model matrix
  var inverseTransposeMatrix = transpose(inverse(modelMatrix));
  var inverseTranspose = gl.getUniformLocation(program, 'inverseTranspose');
  gl.uniformMatrix4fv(inverseTranspose, false, inverseTransposeMatrix);

  // Render
  gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);
};</code></pre>

<br><br><hr><br>


<h4>Hierarchical objects</h4>
<i>(from chapter 9 of the book)</i>

<ul>
<li>A hierarchical object is a model made of several basic objects (called "segments"), like a robotic arm made of many cuboids
<li>Joints are where the segments are linked and rotate relatively to each other, like an elbow
<li>To keep the segments linked to each other, the matrix transformation is inherited from segment to segment
<li>The following demo shows an robotic arm made of three cuboids (click the buttons to make it move)
<li>You can see from line 142 that the vertical "arm" cuboid can rotate around X, and once it's rotated, we perform a negative translation along Y.<br>The result is that the cuboid doesn't rotate around its center, but around a point that is placed 2 units higher: where the arm is attached to the shoulder
<li>Then from line 148, the hand cuboid, which is attached at the end of the arm cuboid, inherits its model matrix, and extends it to add its own rotation and translation.
<br>(The hand rotates along the Y axis, around its own center, but it also has a Y translation, not to change its rotation center but to place it at the end of the arm)
<li>This process can be repeated many times to make a multi-joint object, like an entire robot or a rope!
<li>If many segments are attached to the same parent (for example, the fingers of a hand), they must all reuse the hand's matrix.
<br>This is done in the book's example called <a href="https://xem.github.io/webgl-guide/book/ch09/MultiJointModel.html">MultiJointModel</a>
</ul>

<br>

<iframe id=i15 loading=lazy height=2350 src="https://xem.github.io/webgl-guide/visualizer/?url=15-hierarchical%20object.html&id=i15"></iframe>

<br><br><hr><br>

See <a href="webgl-guide-part-2.html">PART 2</a> for the advanced techniques! :)
</div>

</main>

</div>

<footer></footer>

<script src="../ui.js"></script>
<script>
header();
footer();
menu();
</script>

</body>
</html>
