<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, user-scalable=no">
<html>
<head>
<link rel=stylesheet href="../style.css?v=4">
<title>Maxime Euzi√®re</title>
<base target=_blank>
</head>
<body class=large>

<div class="wrapper">

<header></header>

<div id=menu></div>

<main>

<style>
table { border-spacing: 0; border-collapse: collapse; width: 100% }
th, td { padding: 5px; width: 200px }
th { background: #eee }
h4 { margin-bottom: 0; }
h1 { font-size: 30px }
h2 { font-size: 24px }
h3 { font-size: 20px }
h4 { font-size: 18px }
h5 { font-size: 14px }
ul { padding-left: 15px }
pre { margin: 3px; font-size: 12px; }
.math { margin: 15px 0 }
.section iframe { height: 90vh }
.ch10 { border: 1px solid #000 }
.ch10 * { border: none }
.ch10 td { max-width: 430px; width: auto; vertical-align: top }
.ch10 td + td { max-width: 450px; }

</style>

<div class=section id=webgl_guide>
<h2>WebGL guide</h2>
<h3>october 2019 - may 2020</h3>
  
<h4>Introduction</h4>

<p>This page is a complete, summarized WebGL tutorial, including tiny, embedded, editable demos in each chapter.
<p>It's mainly inspired by the book <a href="https://www.oreilly.com/library/view/webgl-programming-guide/9780133364903/ch01.html">WebGL Programming Guide</a>, the websites <a href="https://webgl2fundamentals.org/">Webgl2Fundamentals.org</a> &amp, <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">mdn.io</a>. 
<p>Starting nearly from scratch, you'll be able to create your own 3D interactive scenes without needing to use any <a href="https://fr.wikipedia.org/wiki/Liste_de_frameworks_WebGL">library or framework</a>: only vanilla JS &amp; WebGL.
<p>My goal was to gather all the information and tricks about WebGL I found scattered everywhere, and present them in a short and helpful way. I hope you'll enjoy it!
<p>The live playground (used for the demos) is available <a href="https://xem.github.io/webgl-guide/visualizer/#PGNhbnZhcyBpZD0iY2FudmFzIiB3aWR0aD00MDAgaGVpZ2h0PTQwMD48L2NhbnZhcz4KPHNjcmlwdD4KLy8gR2V0IHRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dAovLyBUaGUgWCBhbmQgWSBjb29yZGluYXRlcyBhcmUgZGVmaW5lZCBiZXR3ZWVuIC0xLjAgYW5kIDEuMAp2YXIgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgid2ViZ2wiKTsKCi8vIFZlcnRleCBzaGFkZXI6Ci8vIERlc2NyaWJlcyB0aGUgYXR0cmlidXRlcyBvZiBwb2ludHMgaW4gc3BhY2VzIChwb3NpdGlvbiwgc2l6ZSwgLi4uKQovLyAtIGdsX1Bvc2l0aW9uOiB2ZWM0KHgsIHksIHosIDEuMCkKLy8gLSBnbF9Qb2ludFNpemUgZmxvYXQKdmFyIHZzaGFkZXIgPSBgCnZvaWQgbWFpbigpIHsKICBnbF9Qb3NpdGlvbiA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTsKICBnbF9Qb2ludFNpemUgPSAxMC4wOwp9YDsKCi8vIEZyYWdtZW50IHNoYWRlcjoKLy8gRGVzY3JpYmVzIGhvdyBlYWNoIHBpeGVsIGlzIHJlbmRlcmVkIChjb2xvciwgbGlnaHRpbmcsIC4uLikKLy8gLSBnbF9mcmFnQ29sb3I6IHZlYzQociwgZywgYiwgYWxwaGEpCnZhciBmc2hhZGVyID0gYApwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKdm9pZCBtYWluKCkgewogIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKTsKfWA7CgovLyBNYWtlIGEgcHJvZ3JhbSBmcm9tIHRoZXNlIHNoYWRlcnMgYW5kIHVzZSBpdCAKdmFyIHZzID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpOwpnbC5zaGFkZXJTb3VyY2UodnMsIHZzaGFkZXIpOwpnbC5jb21waWxlU2hhZGVyKHZzKTsKCnZhciBmcyA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpOwpnbC5zaGFkZXJTb3VyY2UoZnMsIGZzaGFkZXIpOwpnbC5jb21waWxlU2hhZGVyKGZzKTsKCnZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpOwpnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdnMpOwpnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnMpOwpnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTsKZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTsKCi8vIENsZWFyIHRoZSBjYW52YXMncyBjb2xvciBidWZmZXIsIGluIGJsYWNrCmdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMS4wKTsKZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7CgovLyBEcmF3IHBvaW50cyBvbiB0aGUgY2FudmFzJ3MgY29sb3IgYnVmZmVyCmdsLmRyYXdBcnJheXMoCiAgZ2wuUE9JTlRTLCAvLyBtb2RlCiAgMCwgICAgICAgICAvLyBzdGFydGluZyBwb2ludAogIDEsICAgICAgICAgLy8gbnVtYmVyIG9mIHBvaW50cyB0byBkcmF3Cik7Cjwvc2NyaXB0Pg==">here</a>, my 3D OBJ file parser/viewer is <a href="https://xem.github.io/webgl-guide/">here</a>, and all the source code is available <a href="https://github.com/xem/webgl-guide">on Github</a>.
<p>Helper files created while making this guide: <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/webgl.js">webgl.js</a>, <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a> and <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a>.
<p>If you're interested in Shadertoy, WebGL raymarching and signed distance functions, check out <a href="webgl_quest.html">Webgl quest</a> and <a href="webgl_quest_2.html">Webgl quest 2.</a>
<p>Special thanks to <a href="https://twitter.com/iquilezles">Inigo Quilez</a> and <a href="">Kevin Chapelier</a> for their knowledge and tips!

<br><br><hr><br>
<h2>2D graphics</h2>
<h4>How to draw a point</h4>

<ul>
<li>A vertex is a point in 3D space (coordinates: X, Y, Z).
<li>A fragment is where the scene is rendered (the pixels on your screen).
<li>In a WebGL app, two programs (vertex shader and fragment shader) are written in HLSL language and controlled by JS to render a scene on a canvas:
<li>The <b>vertex shader</b> is executed for every vertex of your scene, and must set two variables called <b>gl_Position</b> and <b>gl_PointSize</b>
<li>The <b>fragment shader</b> is executed for every fragment, and must set the variable <b>gl_FragColor</b> (the color of each pixel).
<li>The source code of both shaders is placed inside a <b>void main(){...}</b> function.
<li>The X and Y coordinates in a WebGL canvas context go from -1 to 1, whatever the size of the canvas.
<br><img src="images/webgl-guide/webgl.png">
<li>In the language HLSL, an <b>int</b> is a whole number (0, 1, 2, ...). A <b>float</b> is a number written with at least one decimal (ex: 0.0, 0.1, 1.0, ...).
<li>A <b>vec4</b> is an array of 4 floats representing either vertex coordinates (x, y, z, 1.0), a color (r, g, b, alpha), or anything you want. (vec2 and vec3 exist too, but are rarely used).
<li>A <b>mat4</b> is a matrix (a grid) of 4 x 4 floats. (mat2 and mat3 exist too, but are also rarely used).
</ul>

<p>Here's the simplest possible WebGL program, drawing a red point in the middle of the canvas. It's a live demo, feel free to play with the code!
<br>
<br>
<iframe id=i1 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=1"></iframe>

<p>The program compilation (lines 30 to 42) is always the same, so I've put it in a compile() function that will be used in the next chapters (see <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/webgl.js">webgl.js</a>):

<pre style="font-size:11px"><code class="lang-js">// Compile a WebGL program from a vertex shader and a fragment shader
compile = (gl, vshader, fshader) => {
  var vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, vshader);
  gl.compileShader(vs);
  var fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, fshader);
  gl.compileShader(fs);
  var program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  gl.useProgram(program);
  console.log('vertex shader:', gl.getShaderInfoLog(vs) || 'OK');
  console.log('fragment shader:', gl.getShaderInfoLog(fs) || 'OK');
  console.log('program:', gl.getProgramInfoLog(program) || 'OK');
  return program;
}</code>
</pre>

<p>Shaders can also contain <a href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)#Functions">custom C-like functions</a>, that can be called inside main().
<p>You may have noticed that the fragment shader starts with a directive that says <b>precision mediump float;</b>:
<br>this is due to the language's specs, which made it mandatory to specify how precise the floats are in this shader.
<br>The possible precisions are "lowp" (less precise but faster), "mediump" and "highp" (more precise but slower), "mediump" is largely enough to compute colors.
<br>The vertex shader can also start with this directive, but defaults to "highp", which is nice (vertex positions need to be very precise).

<br><br><hr><br>

<h4>Custom values: attributes and uniforms</h4>

<ul>
<li>Of course, WebGL wouldn't be interesting if it could just draw one hard-coded point.
<br>It becomes interesting when we give it custom values. This can be done through attributes, uniforms, and buffer objects (we'll see these ones later).
<li>An <b>attribute</b> is a global variable passed by JS to the vertex shader. Its value can change for each vertex (ex: coordinates, position).
<li>An <b>uniform</b> is a global variable passed by JS to both vertex and fragment shaders  (ex: a color). Its value stays constant for an entire draw call.
<li>All the attributes and uniforms received from the JS program must be declared before main() in each shader.
<!--li>For the record, some browsers (like Safari) only accept to draw points that are set by JS, and won't run the previous demo at all.-->
</ul>


<p>Here are the different types of attributes and uniforms that can be set by JS:
<br>

<table border style="table-layout:auto">
<tr>
<th style="max-width:50px">Qualifier<th style="max-width:50px">Type<th>GLSL<th style="width:55%">How to set its value in JS

<tr>
<td rowspan=2>attribute
<td>float
<td><pre>attribute float f;</pre>
<td><pre>gl.vertexAttrib1f(gl.getAttribLocation(program, 'f'), 1.0);</pre>

<tr>
<td>vec4
<td><pre>attribute vec4 v;</pre>
<td><pre>// As a list:
gl.vertexAttrib4f(gl.getAttribLocation(program, 'f'), 1.0, 2.0, 3.0, 4.0);

// or as an Array:
gl.vertexAttrib4fv(gl.getAttribLocation(program, 'f'), [1.0, 2.0, 3.0, 4.0]);</pre>

<tr>
<td rowspan=4>uniform

<td>int
<td><pre>uniform int i;</pre>
<td><pre>gl.uniform1i(gl.getUniformLocation(program, 'f'), 1);</pre>

<tr>
<td>float
<td><pre>uniform float f;</pre>
<td><pre>gl.uniform1f(gl.getUniformLocation(program, 'f'), 1.0);</pre>

<tr>
<td>vec4
<td><pre>uniform vec4 v;</pre>
<td><pre>// As a list:
gl.uniform4f(gl.getUniformLocation(program, 'f'), 1.0, 2.0, 3.0, 4.0);

// or as an Array:
gl.uniform4fv(gl.getUniformLocation(program, 'f'), [1.0, 2.0, 3.0, 4.0]);</pre>

<tr>
<td>mat4
<td><pre>uniform mat4 m;</pre>
<td><pre>gl.uniformMatrix4fv(
  gl.getUniformLocation(program, 'm'), false, new Float32Array([
    1.0, 2.0, 3.0, 4.0,
    5.0, 6.0, 7.0, 8.0,
    9.0, 10.0, 11.0, 12.0,
    13.0, 14.0, 15.0, 16.0
  ])
);</pre>

</table>
<br>
<p>Here's the same demo as before, but this time the position, size and color of the point are set by the JS code:
<br>
<br>
<iframe id=i2 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=2"></iframe>

<br><br><hr><br>
<h4>How to draw many points, a matter of continuity</h4>

<p>First, let's try to edit the previous demo to display other points: for example, you'll see this if you uncomment the lines 47 to 53! (beautiful, isn't it?)
<br><br><img src="images/webgl-guide/rgb.jpg">

<p>WebGL has no problem calling gl.drawArrays many times in a row, but only if it is in the same timeframe.

<p>Here's what happens if we make a program that tries to draw a new random point every 500ms:

<br>
<br>
<iframe id=i3 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=3"></iframe>

<p>As you can see, the canvas is not only cleared, but completely reset each time drawArrays() is called. This is because the draws happen at different moments.
<br>To solve this, there are two solutions:
<br>1) Remember the positions and colors of every point and redraw them all every 500ms;
<br>2) Force <b>{ preserveDrawingBuffer: true }</b>, as you can see by removing the commented code on line 4 (if this is enabled, you can still gl.clear() the canvas manually).

<br><br><img src="images/webgl-guide/points.gif" width=300 loading=lazy>

<br><br><hr><br>

<h4>How to draw lines and triangles</h4>

<ul>
<li>The next step consists in declaring many points at once, and telling WebGL how to display them: as points, as lines or as triangles.
<li>To do this, we'll use an <b>array buffer</b> (an array of numbers) to transmit a list of vertex properties from JS to the fragment shader, via an attribute.
<li>This buffer is encoded in binary, and is interpreted as a list of numbers, formatted as one of these types:
<br>
<br>
<table border>
<tr>
<th>Name
<th>Bounds
<th>JS container
<th>WebGL type

<tr>
<td>Unsigned byte
<td>0 ... 255
<td>new Uint8Array([...])
<td>gl.UNSIGNED_BYTE

<tr>
<td>Signed short integer
<td>‚àí32,768 ... 32,767
<td>new Int16Array([...])
<td>gl.SHORT

<tr>
<td>Unsigned short integer
<td>0 ... 65,535
<td>new Uint16Array([...])
<td>gl.UNSIGNED_SHORT

<tr>
<td>Signed integer
<td>-2,147,483,648 ... 2,147,483,647
<td>new Int32Array([...])
<td>gl.INT

<tr>
<td>Unsigned integer
<td>0 ... 4,294,967,295
<td>new Uint32Array([...])
<td>gl.UNSIGNED_INT

<tr>
<td>Floating point number
<td>none
<td>new Float32Array([...])
<td>gl.FLOAT
</table>
<br>
<li>gl.drawArrays can render points, lines and triangles in 7 different ways, by simply changing its first parameter:
<br>
<br>
<img src="images/webgl-guide/modes.png" width=800 style="border:2px solid #ddd">
</ul>

<p>Here's the simplest way to draw a triangle. You can edit the mode on line 59 to render points or lines instead of a triangle (ex: <mark style="background: #def;padding:3px;">gl.POINTS</mark> or <mark style="background: #def;padding:3px;">gl.LINE_LOOP</mark>).
<p>After binding the data buffer to the WebGL program, we specify the type and the number of values to read for each vertex, in this example it's 2 floats: X and Y (lines 43/44).
<br>
<br>
<iframe id=i4 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=4"></iframe>

<p>You can draw as many triangles as you want by adding vertices on line 33 and updating count on line 61.

<p>The array buffer creation and binding is always the same, so I included it in the function arraybuffer (in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/webgl.js">webgl.js</a>):
<pre style="font-size:11px"><code class="lang-js">// Bind an array buffer to an attribute and enable it
arraybuffer = (gl, data, program, attribute, size, type) => {
  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  var a = gl.getAttribLocation(program, attribute);
  gl.vertexAttribPointer(a, size, type, false, 0, 0);
  gl.enableVertexAttribArray(a);
}</code>
</pre>

<br><hr><br>

<h4>Multi-attribute buffer and varying color</h4>

<ul>
<li>Now imagine that we want to give a specific color to three vertices, and draw a triangle with them.
<li>We can do that by binding two data buffers (one for the vertex positions, another one for the vertex colors), which is totally fine,
<br>but we can also save a bit of resources by using a single data buffer with interleaved data, for example the values X/Y/R/G/B, recurring every 5 floats (see demo below).
<li>The vertex buffer will receive the positions and colors for each vertex and will need to transmit the colors to the fragment buffer.
<br>To do so, we will use a <b>varying</b>: a global variable that is writable by the vertex shader and readable by the fragment shader.
<br>Varyings are declared at the beginning of both shaders, and set in the code of the vertex shader. It's a good practice to name them with a "v_" prefix.
<br>Every fragment (pixel) inside the triangle, if it's bound to a varying color variable, will be interpolated from the color of each vertex around it!
</ul>
<iframe id=i6 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=5"></iframe>

<br><br><hr><br>

<h4>Translate, rotate, scale</h4>

<ul>
<li>If we want to move, rotate or scale a triangle, we need to know how to transform each of its vertices.
<li><b>Translation</b> consists in moving all the vertices in a given direction (increase or decrease its X/Y/Z coordinates).
<li><b>Rotation</b> consists in moving the vertices around a <b>pivot point</b>, with a given angle (a full turn clockwise is 360 degrees or 2 * Pi radians).
<li><b>Scaling</b> consists in making the triangle smaller or bigger by bringing the vertices closer or further from a pivot point.
<li>These operations can be done component per component (compute X, then Y, then Z), but we generally use a much powerful tool: <b>matrix transformations</b>.
<li>Each transformations can be written as a mat4 (a matrix of 4x4 floats), and applied to a vertex's <b>homogeneous coordinates</b> (vec4(X, Y, Z, 1.0)) with a multiplication.
</ul>

<p>
<table border>
<tr>
<th>Transformation
<th style=min-width:250px>Transformation applied to each vertex coordinates
<th><div style="min-width: 260px">transformation via a matrix</div>

<tr>
<td>Identity (no change)
<td>x' = x
<br>y' = y
<br>z' = z
<td style=padding:10px>

<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      √ó
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Translation along X, Y and Z axis
<td>x' = x + Tx
<br>y' = y + Ty
<br>z' = z + Tz
<td style=padding:10px>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Tx</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Ty</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>Tz</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      √ó
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr>
<td>Rotation around the X with an angle œÜ
<br>(œÜ is in radians)
<td>x' = x
<br>y' = y cos œÜ - z sin œÜ
<br>z' = y sin œÜ + z cos œÜ
<td style=padding:10px>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>cos œÜ</mn></mtd>
            <mtd><mn>-sin œÜ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>sin œÜ</mn></mtd>
            <mtd><mn>cos œÜ</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      √ó
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr style=padding:10px>
<td>Rotation around the Y with an angle Œ∏
<td>x' = x cos Œ∏ + z sin Œ∏
<br>y' = y
<br>z' = -x sin Œ∏ + z cos Œ∏
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>cos Œ∏</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>sin Œ∏</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>-sin Œ∏</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>cos Œ∏</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      √ó
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr style=padding:10px>
<td>Rotation around the Z axis with an angle œà
<td>x' = x cos œà ‚Äì y sin œà
<br>y' = x sin œà + y cos œà
<br>z' = z
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>cos œà</mn></mtd>
            <mtd><mn>-sin œà</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>sin œà</mn></mtd>
            <mtd><mn>cos œà</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      √ó
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

<tr style=padding:10px>
<td>Scaling along X, Y and Z axis
<td>x' = Sx * x
<br>y' = Sy * y
<br>z' = Sz * z
<td>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z'</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      =
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>Sx</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Sy</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>Sz</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
  </mrow>
</math>
      √ó
<math xmlns = "http://www.w3.org/1998/Math/MathML">
  <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>x</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>y</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>z</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>

</table>

<ul>
<li>Multiple transformations can be accumulated by multiplying their matrices from right to left.
<br>For example, to translate then rotate a point, multiply in this order: (‚å© rotation matrix ‚å™ √ó ‚å© translation matrix ‚å™) √ó ‚å© coordinates vector ‚å™
<li>Matrices and vectors can be multiplied together natively in GLSL:
</ul>

<iframe id=i5 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=6"></iframe>

<ul>
<li>As you can see on line 14 and 41 to 72, the 3 matrices are declared in JS and sent to the fragment shader, which multiplies them with each vertex position.
<br>This is easy to code, but unfortunately not optimal in real conditions, as the multiplications must be hardcoded in glsl and repeated for every fragment of the program.
<br>In the following examples, the compound transformation matrix will be computed only once (in JS) and passed to the shader.
</ul>

<p>Helper functions added in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a> (because matrices multiplications are not native in JS):
<pre style="font-size:11px"><code class="lang-js">// Create an identity mat4
identity = () => {
  return new Float32Array([
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
  ]);
};

// Compute the multiplication of two mat4 (c = a x b)
multMat4Mat4 = (a, b) => {
  var i, e, a, b, ai0, ai1, ai2, ai3;
  var c = new Float32Array(16);
  for (i = 0; i &lt; 4; i++) {
    ai0 = a[i];
    ai1 = a[i+4];
    ai2 = a[i+8];
    ai3 = a[i+12];
    c[i]    = ai0 * b[0]  + ai1 * b[1]  + ai2 * b[2]  + ai3 * b[3];
    c[i+4]  = ai0 * b[4]  + ai1 * b[5]  + ai2 * b[6]  + ai3 * b[7];
    c[i+8]  = ai0 * b[8]  + ai1 * b[9]  + ai2 * b[10] + ai3 * b[11];
    c[i+12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
  }
  return c;
};

// Transform a mat4
// options: x/y/z (translate), rx/ry/rz (rotate), sx/sy/sz (scale)
transform = (mat, options) => {

  var out = new Float32Array(mat);
  
  var x = options.x || 0;
  var y = options.y || 0;
  var z = options.z || 0;
  
  var sx = options.sx || 1;
  var sy = options.sy || 1;
  var sz = options.sz || 1;
  
  var rx = options.rx;
  var ry = options.ry;
  var rz = options.rz;
  
  // translate
  if(x || y || z){
    out[12] += out[0] * x + out[4] * y + out[8]  * z;
    out[13] += out[1] * x + out[5] * y + out[9]  * z;
    out[14] += out[2] * x + out[6] * y + out[10] * z;
    out[15] += out[3] * x + out[7] * y + out[11] * z;
  }
  
  // Rotate
  if(rx) out.set(multMat4Mat4(out, new Float32Array([1, 0, 0, 0, 0, Math.cos(rx), Math.sin(rx), 0, 0, -Math.sin(rx), Math.cos(rx), 0, 0, 0, 0, 1])));
  if(ry) out.set(multMat4Mat4(out, new Float32Array([Math.cos(ry), 0, -Math.sin(ry), 0, 0, 1, 0, 0, Math.sin(ry), 0, Math.cos(ry), 0, 0, 0, 0, 1])));
  if(rz) out.set(multMat4Mat4(out, new Float32Array([Math.cos(rz), Math.sin(rz), 0, 0, -Math.sin(rz), Math.cos(rz), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])));
  
  // Scale
  if(sx !== 1){
    out[0] *= sx;  
    out[1] *= sx;
    out[2] *= sx;
    out[3] *= sx;
  }
  if(sy !== 1){
    out[4] *= sy;
    out[5] *= sy;
    out[6] *= sy;
    out[7] *= sy;
  }
  if(sz !== 1){
    out[8] *= sz;
    out[9] *= sz;
    out[10] *= sz;
    out[11] *= sz;
  }
  
  return out;
};</code>
</pre>

<h5>How to change the pivot point</h5>

<p>The rotations and scaling matrices, as described above, only allow to use the world's origin (0,0,0) as pivot point.
<br>Imagine a triangle that is not centered on the origin, and needing to rotate 90 degrees (Pi / 2 radins) around its center, for example the point (2,2,0).
<br>The solution is to apply 3 transformation matrices to this triangle's vertices: translate to (0,0,0), then rotate 90 degrees, then translate back to (2,2,0)!

<br><br><hr><br>

<h4>Texturing</h4>

<ul>
<li>As we saw earlier, the colors of the fragments inside a triangle are interpolated from the colors of each vertex around it.
<br>The same principle can be used with a texture image (it's called sampling in this case).
<li>Each texture (square or rectangle) has a local coordinates system (U,V) that goes from 0 to 1, and every vertex can have its own <b>texture coordinates</b> in this system.
<li>A JS Image object can be bound to an <b>uniform sampler2D</b> to create a texture, which is applied to the current fragment using <b>gl_FragColor = texture2D(sampler, coords);</b>
<li>The "pixels" of the texture are called texels. The texture files are generally squared to avoid being stretched in a direction or the other.
<br><img src="images/webgl-guide/texture.png">
</ul>

<p>Here's an example of textured quad (a square made of two triangles). You can edit the numbers to change the way the vertices and texture are mapped:
<p>
<iframe id=i7 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=7"></iframe>

<p>Remember that the values you're manipulating are rgba colors, so you can basically do anything you want with them, like inverting the colors:

<pre class="language-js"><code>vec4 color = texture2D(sampler, v_TexCoord);
gl_FragColor = vec4(vec3(1.0, 1.0, 1.0) - color.rgb, 1.0);</code></pre>

<br><img src="images/webgl-guide/textures0.png">

<h5>Multiple textures</h5>
<p>Two or more textures can also be used at the same time. For example, you can initialize two samplers, and add or multiply them in the fragment shader:
<pre class="language-js"><code>vec4 color0 = texture2D(sampler0, v_TexCoord);
vec4 color1 = texture2D(sampler1, v_TexCoord);
gl_FragColor = color0 + color1;

// or

gl_FragColor = color0 * color1;</code></pre>

<br><img src="images/webgl-guide/textures.png" width=600>

<p>Or blend them together:

<pre class="language-js"><code>gl_FragColor = color0 * 0.25 + color1 * 0.75;</code></pre>

<br><img src="images/webgl-guide/textures2.png" width=600>

<br><br><hr><br>

<h2>3D graphics</h2>
<br>You should know by now that computers don't do "3D" natively.
<br>You (or your 3D framework) will have to do all the computing to simulate the camera, the perspective and how they affect each polygon, so the scene can seem to be in 3D.
<br>Fortunately, the API we use (WebGL) provides very helpful tools (especially data and depth buffers) to help rendering complex scenes without too much effort.
<br>
<h4>3D camera</h4>
<br><img src="images/webgl-guide/frustum.png">
<ul>
<li>In 3D, the "camera", with its position, angle and perspective, is defined by nothing more than a 4x4 matrix.
<li>During render, every vertex in the scene is multiplied by this matrix to simulate these camera properties and appear at the right position.
<li>First, the camera's frustum (field of view angle, aspect ratio, near clip plane and far clip plane) can be set with:

<div class=math>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>1/(aspect*tan(fov/2))</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1/tan(fov/2)</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-(far+near)/(far-near)</mn></mtd>
            <mtd><mn>-(2*far*near)/(far-near)</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-1</mn></mtd>
            <mtd><mn>0</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
</div>

<li>Then, the camera can be translated, rotated and scaled (zoomed) similarly to the vertices, by using the matrices multiplications we saw earlier.
<li>A slightly more advanced LookAt() function is often used by developers to set the camera's position, angle and target all at once.
</ul>
<p>Here are the perspective() and lookAt() functions I added in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a>:

<pre><code class="lang-js">// Create a perspective matrix
// options: fov, aspect, near, far
orthogonal = options => {
  var fov = options.fov || 1.5;
  var aspect = options.ratio || 1; // canvas.width / canvas.height
  var near = options.near || 0;
  var far = options.far || 100;
  var f = 1 / Math.tan(fov);
  var nf = 1 / (near - far);
  return new Float32Array([
    f / aspect, 0, 0, 0, 
    0, f, 0, 0, 
    0, 0, (far + near) * nf, -1,
    0, 0, (2 * near * far) * nf, 0
  ]);
}

// LookAt
lookat = (mat, eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) => {
  var e, fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;
  fx = centerX - eyeX;
  fy = centerY - eyeY;
  fz = centerZ - eyeZ;
  rlf = 1 / Math.sqrt(fx*fx + fy*fy + fz*fz);
  fx *= rlf;
  fy *= rlf;
  fz *= rlf;
  sx = fy * upZ - fz * upY;
  sy = fz * upX - fx * upZ;
  sz = fx * upY - fy * upX;
  rls = 1 / Math.sqrt(sx*sx + sy*sy + sz*sz);
  sx *= rls;
  sy *= rls;
  sz *= rls;
  ux = sy * fz - sz * fy;
  uy = sz * fx - sx * fz;
  uz = sx * fy - sy * fx;
  var l = new Float32Array(
    sx, ux, -fx, 0,
    sy, uy, -fy, 0,
    sz, uz, -fz, 0,
    0,  0,  0,   1
  );
  l = transform(l, {x: -eyeX, y: -eyeY, z: -eyeZ});
  return multMat4Mat4(mat, l); 
}</code>
</pre>

<br>
<p>It's also possible to make an orthogonal camera with no perspective, also called "orthographic", "isometric" or "2.5D" view.
<br>In this case, the frustum is a box:
<br><img src="images/webgl-guide/orthogonal.png">

<div class=math>
<math xmlns = "http://www.w3.org/1998/Math/MathML">
   <mrow>
      <mo>[</mo>
      <mtable>
         <mtr>
            <mtd><mn>2/(right-left))</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-((right+left)/(right-left))</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>2/(top-bottom)</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-((top+bottom)/(top-bottom))</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>-2/(far-near)</mn></mtd>
            <mtd><mn>-((tar+near)/(far-near))</mn></mtd>
         </mtr>
         
         <mtr>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>0</mn></mtd>
            <mtd><mn>1</mn></mtd>
         </mtr>
      </mtable>
      <mo>]</mo>
   </mrow>
</math>
</div>

<p>And the source code:

<pre><code class="lang-js">// Create an orthogonal matrix
// options: top, bottom, left, right, near, far
orthogonal = options => {
  var top = options.top;
  var bottom = options.bottom;
  var left = options.left;
  var right = options.right;
  var near = options.near || 0;
  var far = options.far || 100;
  var rw = 1 / (right - left);
  var rh = 1 / (top - bottom);
  var rd = 1 / (far - near);
  return new Float32Array([
    2 * rw, 0, 0, 0,
    0, 2 * rh, 0, 0,
    0, 0, -2 * rd, 0,
    -(right + left) * rw, -(top + bottom) * rh, -(far + near) * rd, 1
  ]);
}</code>
</pre>

<p>You may have noticed that the matrix is different in the mathematic formula and in the source code.
<br>This is because WebGL requires that all the matrices used in the shaders are transposed (i.e. X and Y axis are inversed).
<br>You don't need to worry about it when using the functions in  <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a>, but otherwise, you can either write your matrices already transposed, or use this function:

<pre><code class="lang-js">// Get the transposed of a mat4
transpose = m => {
  return new Float32Array([
    m[0], m[4], m[8],  m[12],
    m[1], m[5], m[9],  m[13],
    m[2], m[6], m[10], m[14],
    m[3], m[7], m[11], m[15]
  ]);
};</code>
</pre>

<br><br><hr><br>

<h4>Reduce repetitions with indexed vertices</h4>

<ul>
<li>As we have seen before, data buffers (with the type gl.ARRAY_BUFFER) can hold vertex properties (position, color, texture coordinates...).
<li>These properties can be placed into multiple buffers or interleaved into a single one.
<li>In 3D, vertices are often shared between multiple triangles.
<li>Instead of repeating the same vertices many times in the same buffer, it's possible to write each vertex only once in a data buffer,<br>and use a second buffer with the type <b>gl.ELEMENT_ARRAY_BUFFER</b> that declares all our triangles by using indices of the first object.
<li>Even if many data buffers exist in your program, only one index buffer can be used, and it will list indices from all the data buffers at once,<br>so they all need to be stored in the same order (the N'th item of every buffer must belong to the same N'th vertex).
<li>Finally, to draw indexed vertices, you need you replace gl.drawArrays with <b>gl.drawElements(type, count, type, offset)</b>
<br>Warning: contrary to drawArrays(), the second parameter is the number of polygons, not the number of vertices!
<br>Firefox will refuse to draw anything if the count parameter is too big, but Webkit browsers will work without any warning.
<li>The indices stored in the index buffer have integer values (N = 0, 1, 2...), and you can choose their size in bytes depending on the number of indices:
<br>
<br>
<table border>
<tr>
<th>Number of vertices to index
<th>Index buffer type
<th>drawElements type
<tr>
<td>&lt;= 256
<td>Uint8Array([...])
<td>gl.UNSIGNED_BYTE
<tr>
<td>&lt;= 65536
<td>Uint16Array([...])
<td>gl.UNSIGNED_SHORT
<tr>
<td>&lt;= 4294967296
<td>Uint32Array([...])
<td>gl.UNSIGNED_INT (*)
</table>

<p>(*) In WebGL1, an extension must be enabled before using the type UNSIGNED_INT: <b>gl.getExtension('OES_element_index_uint');</b>. In WebGL2, it's enabled by default.
</ul>

<p>The following demos will use indexed buffers to render 3D objects.


<br><br><hr><br>

<h3>Hello cube</h3>

<p>The easiest 3D shape to render is a cube. But to make WebGL draw triangles in 3D, two new settings must be used:
<ul>
<li>In order to make each triangle appear at the right depth (the front ones in front, the back ones in the back), depth-sorting must be enabled with <b>gl.enable(gl.DEPTH_TEST);</b>
<li>The clear code is also updated to take this depth test into account: <b>gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</b>
</ul>

<iframe id=i8 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=8"></iframe>

<br><br><hr><br>

<h3>Color each face of the cube</h3>

<ul>
<li>In this case, each vertex doesn't have a single color: it has a different color depending on which face is being rendered
<li>Thus, we need to declare the vertices of each face separately in an array buffer, then the colors of each vertex of each face in another array buffer, and finally, use an index buffer that references both vertices and colors:
</ul>

<iframe id=i9 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=9"></iframe>

<p>I've added the cube declaration in the cube() function of <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a> to avoid repeating it in the next demos

<br><br><hr><br>

<h4>Lighting and shading</h4>

<h5>Diffuse light</h5>
<ul>
<li>Diffuse light reflexion is visible when the light is reflected in all directions as it hits a face of the cube
<li>To do that, we need to define a light with a color (for example, white), and a direction (for example, vec3(0.5, 3.0, 4.0))
<li>Each face has <b>normal</b>: a vec3 pointing to the outside of the cube, with a length of 1, i.e. "normalized"
<li>In the fragment shader, we perform a <b>dot product</b> between the light vector and the face normal, to determine how much the light is diffused
<br><blockquote class="twitter-tweet"><p lang="en" dir="ltr">dot product - visualized ‚ö™<br><br>the dot of two normalized vectors, as shown here, can say how similar they are<br><br>a ‚Ä¢ b = 1, same direction<br>a ‚Ä¢ b = 0, perpendicular<br>a ‚Ä¢ b = -1, opposite directions<br><br>you might also be able to see why it&#39;s sometimes called scalar projection~ <a href="https://t.co/vg8TwNZ8qs">pic.twitter.com/vg8TwNZ8qs</a></p>&mdash; Freya Holm√©r (@FreyaHolmer) <a href="https://twitter.com/FreyaHolmer/status/1200807790580768768?ref_src=twsrc%5Etfw">November 30, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
<li>If the dot product is negative, we set it to "0" (there can't be a negative amount of light). This is done with <b>max(dot(light, normal), 0.0);</b>
<li>The color sent to the fragment shader is: the light's color (rgb) √ó the face color (rgb) √ó the dot product of the normal and the light, and the color's alpha is set to 1.0
<li>In HLSL, the composants of a vec4 can be accessed with .x/y/z/t (if it's a position) or .r/g/b/a (if it's a color). Composants can be composed too (ex: <b>vec3 rgb = col.rgb</b>)
</ul>

<iframe id=i10 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=10"></iframe>

<br><h5>Ambient light</h5>

<p>With diffuse lighting alone, some faces are too dark, like the rightmost one here. To fix that, we can add an <b>ambient light</b> (added equally to every vertex's color):
<br>
<br>
<iframe id=i11 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=11"></iframe>

<br>
<h5>Point light</h5>

<p>With diffuse and ambient lights alone, each face gets a flat color. It's called polygonal or facetted rendering, and isn't realistic (it's great for retro-looking games though)  
<ul>
<li>To enhance that, we can use a <b>point light</b> representing the sun or a light bulb, with a specific position and color
<li>With such a point light in the scene, the shading will be able to vary according to the distance between each point of the cube and the point light
<li>When it's computed per vertex (see the book's demos: <a href="https://xem.github.io/webgl-guide/book/ch08/PointLightedCube.html">cube</a> / <a href="https://xem.github.io/webgl-guide/book/ch08/PointLightedSphere.html">sphere</a>), it looks a bit nicer but still not great due to the imprecise color interpolation
<br>
<br><img src="images/webgl-guide/per_vertex.png" width=500>
<li>A better solution consists in computing the right color for every fragment of the cube (i.e. every pixel),<br>and that's exactly what the fragment shader is here for! (see the book's demos: <a href="https://xem.github.io/webgl-guide/visualizer/?url=12-point">cube</a> / <a href="http://xem.github.io/webgl-guide/book/ch08/PointLightedSphere_perFragment.html">sphere</a>)
<br><img src="images/webgl-guide/sphere.png" width=500>
</ul>
<br>
<iframe id=i12 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=12"></iframe>

<h5>Smooth shading</h5>

<ul>
<li>With the lighting methods we've seen before, a complex shape will always have "hard edges" (abrupt changes of lighting between two faces)
<li>This is because each face has an unique normal vector, shared between all its vertices
<li>Smooth shading consists in computing a different normal for each vertex, equal to the sum of the normals of all the faces it belongs to (as explained <a href="https://www.iquilezles.org/www/articles/normals/normals.htm">here</a>!)
<br>(in the end, the shaders normalize the normals, so it's equivalent to computing a mean of the face normals)
<li>Example: a 3D model with smooth shading disabled / enabled
<br><br><img src="images/webgl-guide/w5.gif" width=600>
</ul>

<br>
<h5>Other types of lighting</h5>
<ul>
<li>Emissive lighting: when an object is self-illuminated - this can be easy if you just want to make the fragments lighter (multiply the color with a value higher than 1), or very complicated if you want the surface to illuminate surrounding objects (this will not be covered here :p )
<li>Specular lighting: when an object is more or less shiny, it can reflect a point light like a mirror under a certain angle (more info <a href="https://webgl2fundamentals.org/webgl/lessons/webgl-3d-lighting-point.html">here</a>)
<br>The idea is to compute the half-vector between the camera, the fragment and the light, and compare this with the surface normal using a dot product
<br><img src="images/webgl-guide/specular.png">

<pre><code class=lang-js>var fshader = `
(...)
float shininess = 150.0;
vec3 surfaceWorldPosition = (u_world * a_position).xyz;
vec3 v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;
vec3 v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;
vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
vec3 surfaceToCameraDirection = normalize(v_surfaceToCamera);
vec3 halfVector = normalize(surfaceToLightDirection + surfaceToCameraDirection);
float light = dot(normal, surfaceToLightDirection);
# the pow is to avoid having specular reflection that's too shiny
float specular = pow(dot(normal, halfVector), shininess);
color.rgb *= light * lightColor;
color.rgb += specular * specularLightColor;
(...)
`;</code></pre>

<h5>Lighting and coloring are the same</h5>

<p>You may find documents talking about ambient/diffuse/specular colors. It's the same thing as ambient/diffuse/specular lighting
<br>And it makes sense: in CG, like in the real world, the colors emitted by an object depend entirely on its lighting

<h5>Lighting and shading are not the same</h5>
<p>The two terms are often mixed but lighting is really a physics notion (how the light affects an object) while shading is purely CG-related (how a pixel is rendered) 
<br><br><hr><br>

<h4>Transforming the shaded cube</h4>

<ul>
<li>So far, we've only transformed the camera matrix, to make it revolve around the cube
<li>Due to the lack of light or other cubes in the scene, it was equivalent to having the cube rotate on itself
<li>Now that we have a fixed point light in the scene, if we want to rotate, translate or scale the cube, we need to do two things:<br>- introduce a <b>model matrix</b> (the transformation matrix of the cube),<br>- recompute the 6 cube's normals and the lighting of every fragment when the model matrix is updated
<li>Computing a face normal from scratch can be done using a cross-product of two face vectors respecting the right hand rule (AB √ó BC if the points A, B and C are arranged counterclockwise)
<p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">cross product - visualized ‚öî<br><br>the cross product A √ó B is a super useful way to take two 3D vectors, and get a third vector *perpendicular to both*, shown in blue (with its length shown in gray)! <a href="https://t.co/d3NZoLEUtq">pic.twitter.com/d3NZoLEUtq</a></p>&mdash; Freya Holm√©r (@FreyaHolmer) <a href="https://twitter.com/FreyaHolmer/status/1203059678705602562?ref_src=twsrc%5Etfw">December 6, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<li>Though, it's simpler to only compute the normals once, on load, and pass them to the vertex shader, along with the vertex position and the face color
<br>
Then, when the model matrix changes, the trick is compute its inverse transpose (in JS) and pass it to the vertex shader
<br>
In the vertex shader, the original normal just needs to be multiplied by this matrix to obtain its new value: <b>vec3 newNormal = oldNormal * inverseTranspose</b>
<li>Here are the functions I added in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/matrix.js">matrix.js</a> to compute the inverse transpose:

<pre><code class="lang-js">// Get the transposed of a mat4
transpose = m => {
  return new Float32Array([
    m[0], m[4], m[8],  m[12],
    m[1], m[5], m[9],  m[13],
    m[2], m[6], m[10], m[14],
    m[3], m[7], m[11], m[15]
  ]);
};

// Get the inverse of a mat4
inverse = m => {
  var inv = new Float32Array([
     m[5]*m[10]*m[15] - m[5]*m[11]*m[14] - m[9]*m[6]*m[15] + m[9]*m[7]*m[14] + m[13]*m[6]*m[11] - m[13]*m[7]*m[10],
    -m[1]*m[10]*m[15] + m[1]*m[11]*m[14] + m[9]*m[2]*m[15] - m[9]*m[3]*m[14] - m[13]*m[2]*m[11] + m[13]*m[3]*m[10],
     m[1]*m[6]*m[15]  - m[1]*m[7]*m[14]  - m[5]*m[2]*m[15] + m[5]*m[3]*m[14] + m[13]*m[2]*m[7]  - m[13]*m[3]*m[6],
    -m[1]*m[6]*m[11]  + m[1]*m[7]*m[10]  + m[5]*m[2]*m[11] - m[5]*m[3]*m[10] - m[9]*m[2]*m[7]   + m[9]*m[3]*m[6],
    -m[4]*m[10]*m[15] + m[4]*m[11]*m[14] + m[8]*m[6]*m[15] - m[8]*m[7]*m[14] - m[12]*m[6]*m[11] + m[12]*m[7]*m[10],
     m[0]*m[10]*m[15] - m[0]*m[11]*m[14] - m[8]*m[2]*m[15] + m[8]*m[3]*m[14] + m[12]*m[2]*m[11] - m[12]*m[3]*m[10],
    -m[0]*m[6]*m[15]  + m[0]*m[7]*m[14]  + m[4]*m[2]*m[15] - m[4]*m[3]*m[14] - m[12]*m[2]*m[7]  + m[12]*m[3]*m[6],
     m[0]*m[6]*m[11]  - m[0]*m[7]*m[10]  - m[4]*m[2]*m[11] + m[4]*m[3]*m[10] + m[8]*m[2]*m[7]   - m[8]*m[3]*m[6],
     m[4]*m[9]*m[15]  - m[4]*m[11]*m[13] - m[8]*m[5]*m[15] + m[8]*m[7]*m[13] + m[12]*m[5]*m[11] - m[12]*m[7]*m[9],
    -m[0]*m[9]*m[15]  + m[0]*m[11]*m[13] + m[8]*m[1]*m[15] - m[8]*m[3]*m[13] - m[12]*m[1]*m[11] + m[12]*m[3]*m[9],
     m[0]*m[5]*m[15]  - m[0]*m[7]*m[13]  - m[4]*m[1]*m[15] + m[4]*m[3]*m[13] + m[12]*m[1]*m[7]  - m[12]*m[3]*m[5],
    -m[0]*m[5]*m[11]  + m[0]*m[7]*m[9]   + m[4]*m[1]*m[11] - m[4]*m[3]*m[9]  - m[8]*m[1]*m[7]   + m[8]*m[3]*m[5],
    -m[4]*m[9]*m[14]  + m[4]*m[10]*m[13] + m[8]*m[5]*m[14] - m[8]*m[6]*m[13] - m[12]*m[5]*m[10] + m[12]*m[6]*m[9],
     m[0]*m[9]*m[14]  - m[0]*m[10]*m[13] - m[8]*m[1]*m[14] + m[8]*m[2]*m[13] + m[12]*m[1]*m[10] - m[12]*m[2]*m[9],
    -m[0]*m[5]*m[14]  + m[0]*m[6]*m[13]  + m[4]*m[1]*m[14] - m[4]*m[2]*m[13] - m[12]*m[1]*m[6]  + m[12]*m[2]*m[5],
     m[0]*m[5]*m[10]  - m[0]*m[6]*m[9]   - m[4]*m[1]*m[10] + m[4]*m[2]*m[9]  + m[8]*m[1]*m[6]   - m[8]*m[2]*m[5]
  ]);
  det = m[0]*inv[0] + m[1]*inv[4] + m[2]*inv[8] + m[3]*inv[12];
  if(!det) return m;
  det = 1 / det;
  for(var i = 0; i < 16; i++) {
    inv[i] *= det;
  }
  return inv;
};</code></pre>

<li>We also pass a "mvp" (model view projection) matrix to the vertex shader, which is the multiplication of the camera matrix and the model matrix
</ul>

<p>Here's a cube rotating on itself with a fixed camera and a fixed point light:
<br>
<br>

<iframe id=i13 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=13"></iframe>

<p>Note: if the model matrix is only a rotation or an uniform scaling, the inverse transpose matrix will be equal to the model matrix. But in any other transformation or combination of transformations, it will have a specific value that will let the shader compute the new normals with a simple multiplication (more info <a href="https://stackoverflow.com/questions/13654401/why-transforming-normals-with-the-transpose-of-the-inverse-of-the-modelview-matr">here</a>)


<br><br><hr><br>

<h4>Drawing many cubes</h4>

<ul>
<li>Of course, it's possible to declare the vertices coordinates, colors and normals of each cube, but that would be very verbose
<li>Instead, we can consider the cube we already declared at the center of the scene as a model
<li>For each cube we want to draw, we simply need to transform this model (by setting the model matrix, mvp matrix and inverse transpose matrix) and render it
</ul>

<br><p>Here's a demo with 3 red cuboids (deformed cubes)
<br><br>
<iframe id=i14 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=14"></iframe>

<p>To avoid repetitions, I added a drawShape function in <a href="https://github.com/xem/webgl-guide/blob/gh-pages/lib/shapes.js">shapes.js</a>, with optional scaling along X/Y/Z:

<pre><code class="lang-js">// Draw the current shape
drawShape = (gl, program, cameraMatrix, modelMatrix, sx = 1, sy = 1, sz = 1) => {
  
  // Set the model matrix (add the custom scale if any)
  var model = gl.getUniformLocation(program, 'model');
  modelMatrix = transform(modelMatrix, {sx, sy, sz});
  gl.uniformMatrix4fv(model, false, modelMatrix);

  // Set the cube's mvp matrix (camera x model)
  var mvpMatrix = multMat4Mat4(cameraMatrix, modelMatrix);
  var mvp = gl.getUniformLocation(program, 'mvp');
  gl.uniformMatrix4fv(mvp, false, mvpMatrix);

  // Set the inverse transpose of the model matrix
  var inverseTransposeMatrix = transpose(inverse(modelMatrix));
  var inverseTranspose = gl.getUniformLocation(program, 'inverseTranspose');
  gl.uniformMatrix4fv(inverseTranspose, false, inverseTransposeMatrix);

  // Render
  gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);
};</code></pre>

<br><br><hr><br>


<h4>Hierarchical objects</h4>

<ul>
<li>A hierarchical object is a model made of several basic objects (called "segments"), like a robotic arm made of many cuboids
<li>Joints are where the segments are linked and rotate relatively to each other, like an elbow
<li>To keep the segments linked to each other, the matrix transformation is inherited from segment to segment
<li>The following demo shows an robotic arm made of three cuboids (click the buttons to make it move)
<li>You can see from line 142 that the vertical "arm" cuboid can rotate around X, and once it's rotated, we perform a negative translation along Y.<br>The result is that the cuboid doesn't rotate around its center, but around a point that is placed 2 units higher: where the arm is attached to the shoulder
<li>Then from line 148, the hand cuboid, which is attached at the end of the arm cuboid, inherits its model matrix, and extends it to add its own rotation and translation.
<br>(The hand rotates along the Y axis, around its own center, but it also has a Y translation, not to change its rotation center but to place it at the end of the arm)
<li>This process can be repeated many times to make a multi-joint object, like an entire robot or a rope!
<li>If many segments are attached to the same parent (for example, the fingers of a hand), they must all reuse the hand's matrix.
<br>This is done in the book's example called <a href="https://xem.github.io/webgl-guide/book/ch09/MultiJointModel.html">MultiJointModel</a>
</ul>

<br>

<iframe id=i15 loading=lazy src="https://xem.github.io/webgl-guide/visualizer/?demo=15"></iframe>

<br><br><hr><br>

<p>At this point we've covered all the basis of 2D and 3D rendering.
<p>See <a href="webgl-guide-part-2.html">PART 2</a> for the advanced techniques! :)
</div>
</div>

</main>

</div>

<footer></footer>

<script src="../ui.js"></script>

<script>
header();
footer();
menu();
</script>

<script>
if(navigator.userAgent.includes("WebKit")){

scr = document.createElement("SCRIPT");
scr.src = 'https://polyfill.io/v3/polyfill.min.js?features=es6';
document.body.appendChild(scr);

scr = document.createElement("SCRIPT");
scr.id = 'MathJax-script';
scr.setAttribute('async', true); 
scr.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
document.body.appendChild(scr);
}

</script>

</body>
</html>
