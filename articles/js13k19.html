<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, user-scalable=no">
<html>
<head>
<link rel=stylesheet href="../style.css?v=4">
<title>Maxime Euzière</title>
<script type="text/javascript" src="https://ff.kis.v2.scr.kaspersky-labs.com/FD126C42-EBFA-4E12-B309-BB3FDD723AC1/main.js" charset="UTF-8"></script></head>
<body>

<div class="wrapper">

<header></header>

<div id=menu></div>

<main>

<div class=section id=js13k19>
<h2>JS13kGames 2019</h2>
<h3>august-september 2019</h3>

<br>
<hr>
<br>

<h3>Intro</h3>

<p>Hi! This is a WIP article!

<!--<p><b>TL;DR:</b>

<p>
<ul>
<li> ... is playable <a href="">HERE</a> (source code <a href="">HERE</a>)
<li> ... is playable <a href="">HERE</a> (source code <a href="">HERE</a>)
<li>Tools developed before and during this compo:
<br>- <a href="https://xem.github.io/terser-online/">Terser-online</a>
<br>- <a href="https://github.com/xem/CSS3Dframework">CSS3Dframework</a>
<br>- <a href="https://twitter.com/MaximeEuziere/status/1157563570823081984">MiniDragAndDrop</a>
<br>- <a href="https://xem.github.io/miniPixelArt/">MiniPixelArt</a>
<br>- <a href="https://xem.github.io/mini2Dphysics">Mini2Dphysics</a>
<br>- <a href="">MiniPartition</a>
</ul>

<p>Results:
<ul>
<li>...
</ul>
-->
<br>
<br>
<hr>
<br>

<style>
blockquote { width: 450px; max-width: 100%; border: 2px solid #def; border-radius: 5px; padding: 0 10px 10px; }
img { border: 1px solid }
</style>

<h3>Before the compo</h3>

<h4>Ideas list</h4>

<p>Since last JS13kGames, while waiting for the theme, I prepared a list of ideas that looked like this:
(hidden for now)
<!--script src="https://gist.github.com/xem/4e0282d261bc9bf749dce741812799cc.js"></script-->

<h4>Tools</h4>
<p>I also made some tools, such as:
<br>- <a href="https://xem.github.io/terser-online/">this online ES6 minifier</a> (optimized for js1k/js13k extreme compression),
<br>- <a href="https://xem.github.io/miniPixelArt/">this pixel-art editor</a> (with tiny JS export),
<br>- <a href="https://github.com/xem/CSS3Dframework">this CSS3D framework</a> (that helps making CSS3D scenes super easily),
<br>- <a href="https://twitter.com/MaximeEuziere/status/1151566587570397186">this music partition editor</a> (with the great help of @d_gnhia),
<br>- <a href="https://github.com/xem/mini2Dphysics">this mini 2D physics engine</a> (that I submitted during JS1K 2019).
<br>- <a href="https://github.com/xem/miniOrchestra">this multi-instrument  music editor</a> (based on <a href="//github.com/xem/miniMusic>MiniMusic</a>, but with many more options).
<br>
<p>Fun fact: @udxs made a meme about me and all the tools I've made:
<br>
<p><img src="./images/js13k19/1.jpg" width='80%'>
<br>
<p>It's a running gag since:
<p><img src="./images/js13k19/1.5.png" width='80%'>
<br>
<p>These tools are now present in the <a href="https://js13kgames.github.io/resources/">resource page of JS13k</a>, along with 24 others tools I had made since 2015.
<p>@end3r, who organizes JS13k every year, even mentioned my contribution <a href="https://medium.com/js13kgames/help-promote-js13k-532616fbe217">in his "HELP PROMOTE JS13K" blog post</a>! Thanks to him!
<br>
<p>During all the month of the compo, I've seen a lot of people thanking me on Slack and on Twitter for my sound, art and compression tools, and telling me they're happily using them.
<br>I'm so glad I could help them make their games look and sound better through my tools! <3

<br>
<br>
<h4>Storyteller?</h4>
<p>I was VERY interested in the first idea of the list: a comics puzzle game inspired by the indie game <a href="http://www.storyteller-game.com/">Storyteller</a>.
<br>For a better idea of the concept, take a look at this video:
<br><iframe width="400" height="350" src="https://www.youtube.com/embed/JmKjsVHi-tM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<br>
<br>I made <a href="https://twitter.com/MaximeEuziere/status/1157563570823081984">a mini drag&drop library</a>, just in case I'd make this game for JS13k19.
<br>I also started coding a mini game engine prototype with emoji, because I was too curious to discover how such a system could be implemented.
<br>
<p><img src="images/js13k19/2.png" width=500>
<br>
<p>It was actually easier than I thought: the engine basically needs to know the characters' characteristics and emotions in a given frame (and sometimes the previous frame) and a list of hardcoded rules to determine the outcome of the current frame.
<br>
<p>Based on the video above, I was able to write a list of 44 rules (without implementing them).
<br>Most of them consist of a single, easy test.
<br>For example, "if someone is close to a treasure: he/she becomes rich; If someone else is closer to the treasure in the next frame: he/she stole the treasure to the other person and the other person hates him/her").
<br>
<p>The most important rule of the game (and the most complex one) is the one that make two people become lovers. This can happen:
<br>- if both are alive;
<br>- if both of them are the same species (human or vampire);
<br>- if both are close physically (if two women are present in the scene, a man will love the closest one, and vice versa);
<br>- if both are single (or not loyal to their lover);
<br>- if both are straight and of different sex, or gay and same sex, or bi;
<br>- if they're of the same social status (both poor, or both rich, or a princess and a hero);
<br>- if none of them is mourning a lover dead at the previous frame;
<br>- if none of them is heartbroken;
<br>- if none of them is angry at the other;
<br>- if none of them is shocked by a crime made by the other;
<br>- if none of them is greedy and close to a treasure;
<br>- if none of them is an Old Mentor (single for life);
<br>- if none of them is a human near to a vampire (because vampires make every human ar fall in love with them).
<br>
<p>This can seem complicated, but with the right data structures, it's just a matter of "if" tests performed in the right order.
<br>
<p>In the end, I did not make this game for JS13k19, but I had a lot of fun figuring out how it worked. And I'm also glad I could develop MiniDragAndDrop while preparing it.
<br>
<br>
<hr>
<br>
<h3>Week 1</h3>
<h4>The theme</h4>
<p>The theme "BACK", was very inspiring, even though it seemed very similar to a previous theme called "REVERSE"...
<p>Fun fact: I spent all the previous year saying to @end3r that the theme of next JS13k should be "BACKSEAT", in reference to Notch's answer when I pointed at some optimizations he could add in his code last year.
<br>
<p><p><img src="images/js13k19/3.png">
<br>
<p>A few minutes before the start of the compo, @end3r pushed the joke a bit further by hinting this:
<br>
<p><img src="images/js13k19/4.png">
<br>
<h4>Ideas</h4>
<p>I started scribbling some ideas on my notepad:
<br><p><img src="images/js13k19/5.png">
<br>
<p>Three ideas from my list could easily be adapted to this theme:
<br>- The Storyteller clone (a.k.a. "Backstory", because you have to change the comic's events to match a story's conclusion)
<br>- The Trackmania Original demake (a.k.a. "Back on track", because it revives an old game and some of its puzzles actually require to go backward on the track to win)
<br>- The Mario 64 demake (because replaying it today would be a long jump back in time)
<br>
<p>Other ideas directly inspired by the theme also included:
<br>- "Backward": a collection of iconic video games levels that you have to play from the end to the start, with a completely inverted goal (for example, in Backwards Mario, you start from the flag and go througs the course from right to left. In backwards Pac-Man, you need to fill the area with gums. Etc!)
<br>- "Back in time": a platform game where you have the ability to go back in time, and use your past/future selves to pass obstacles.
<br>
<h4>Choosing an idea...</h4>
<p>My choice was finally to do something like <b>Trackmania</b>.
<br>
<p><img src="images/js13k19/6.png" width=300>
<br>
<p>Adios, other ideas!
<br>- Storyteller's author (who was okay to let me make a game inspired by his concept) told me that his game is close to an official release, so I didn't want to "steal" his level ideas...
<br>- The Mario 64 demake would be so much work, and I won't have enough free time to do it well in one month...
<br>- The game compiling famous levels played backwards may infrige a lot of copyrights, even if I alter the graphics and audio, and moreover, I'm not sure at all if it would be fun to play...
<br>- The Back in time platformer would be cool, but it may be redundant with a lot of time travel entries made this year, and with my 2016 game <a href="https://js13kgames.com/entries/super-chrono-portal-maker">Super Chrono Portal Maker</a> which also used this mechanic a lot...
<br>
<p>Why Trackmania then?
<br>- It fits the theme and it even fits the joke behind the theme ("backseat" is nice for a racing game...)
<br>- Trackmania (from 2003), a.k.a. Trackmania Original (the 2005 remake), is one of my favourite games, and it's almost impossible to install it on a modern PC: It's not available on Steam/GoG/Epic, and even if you buy the CD of the game (like I did), you're forced to crack it in order to play on Windows 8 or 10.
<br>- I have almost no idea how to implement it, even less in 13kb, and it's the kind of challenge I'm looking for.
<br>
<p>So I decided that a demake of this game would not only be a great programming and compression challenge, and a new type of game for me (racing), but also a good way for everyone to enjoy the good parts of this rare game 16 years after its release!
<br>
<h4>Choosing a game name</h4>
<p>When I wrote this idea in my list, I thought "13Kmania" would be a good name. (Especially in french, where "treize K mania" sounds a lot like "Trackmania".
<p>But to be more theme-friendly, I decided to use "Back on Track" instead!
<br>
<h4>Specs</h4>
<p>Since my entry is a hommage to an abandonware (eh, it's even downloadable on archive.org for free!), I won't try to be super original, but instead, make a game that feels like the real one, with the same puzzles and races, just a lot simpler visually.
<br>It'll still be a huge task for me because I'll have to make vehicles, dozens of connectable road blocks, a map editor, and a convincing racing simulation in 13kb, in 3D, and in 30 days. 😰
<br>By the way: this project will have zero planning. I'll code what I want everyday and we'll see where it goes! (this is probably an extra challenge, but it might be fun at least)
<br>
<h4>Technology</h4>
<p>I know 3 ways to do 3D in a mini game: CSS3D, vanilla WebGL (with raymarching), and points projection.
<br>I first tried to go with point projection to try to make a game that is less resource-intensive. Unfortunately, I got stuck very early, when I tried to draw a (road) polygon that moved behind the camera. At this moment, the projection becomes erratic and I have no idea how to fix it...
<br><p><img src="images/js13k19/7.gif" width=200>
<br>(this gif shows my attempts to make a square that goes from front to back under the camera, in perspective. As soon as the distance between a point and the camera is negative, I have no way to project my polygons reliably)
<br>
<p>WebGL would look very nice but I'm afraid I'll lose too much time trying to make it work.
<br>
<p>So, let's go with CSS3D, and this time, with the help of my mini framework that hides most of the complexity!
<br>Space will be tight, so I removed everything I didn't need from my framework (set_unit(), set_perspective(), pyramid(), cylinder(), many "origins" and all the optional CSS...) and started the project with a ~1kb overhead (instead of 1.7kb for the full package)
<br>
<h4>Baby you can drive my car</h4>
I created two red cubes for the car's body, 4 grey circles for the wheels, 4 grey rectangles perpendicular to the wheels to simulate their depth (when they're seen from behind), added two different shades of red for the back and right faces of the car (for "lighting"), plugged the famous <a href="https://xem.github.io/articles/jsgamesinputs.html">73b JS keyboard controls</a> plus a bit of trigonometry, and after a couple hours, we already have a little controllable car!
<p>Let's go! For the record, we're on day 2.
<br><p><img src="images/js13k19/8.gif" width=300>
<br>Polygon count: 20 (+3 for the ground).
<br>Byte count: 6.59kb commented, 4.55kb minified, 1.69kb zipped.
<br>Hours count: 2 (I only count the hours where I actively work with my pen or my code editor, not all the idle thinking in between :p) 
<br><a href="http://xem.github.io/js13k19/day2">DEMO</a>
<br>
<h4>Backseating the camera</h4>
Day 3: let's make the camera follow the car but not too rigidly:
<br>Instead of having a fixed view of the back side of the car, it's preferable to see it turn on itself a little when the player presses "left" or "right". The distance car-camera stays fixed though..
<br>
<p>Let's do a bit of math:
<br><p><img src="images/js13k19/9.png">
<br>- At any given moment, the car is at a position [x:y], and rotated on the map with an angle a (here, 45° or Pi/4 radians)
<br>- If the player presses "left" or "right", the angle a decreases or increases.
<br>- If the player presses "up", the car moves 10px along its angle. To do that, we add (cos(a) * 10px) to x and we subtract (sin(a) * 10px) to y.
<br>- If the player presses "down", the car moves back 10px. To do that, we subtract (cos(a) * 10px) to x and we add (sin(a) * 10px) to y.
<br>- To keep seeing the car from behind, the camera must be centered on the new position [x:y], but with an angle equal to -a (-45°).
<br>- The distance car-camera stays fixed "for free" because it is the perspective distance of our CSS3D scene.
<br>- Finally, to make the camera follow the car less rigidly, add a little delay to its position and rotation changes. By chance, this can be done with a CSS transition: "#scene{transition:.25s linear}"
<br>Repeat this 30 times per second and you have a mini racing game!<br>
<br>
<p>Just for the record: this is not easy at all for me. I'm getting more and more used to it, but it still took me a while to figure out which numbers and trigonometric functions I had to use at each step! (and I'm pretty sure the rest will be much harder)
<br>Also, I noticed that Chrome goes crazy when we try to update elements with CSS transitions 30 times per second. So the transitions will be only be enabled on Firefox.
<br>
<h4>Acceleration</h4>
Let's take a moment to make the car accelerate when we press up and decelerate / goes back when we press down.
<br>To do this, we don't update the car's position directly at each frame with a fixed amount.
<br>Instead, we increase or decrease a variable representing the car's speed, and add this speed to the car's position at each frame.
<br>
<p><img src="images/js13k19/10.gif" width=300>
<br>Polygon count: still 23.
<br>Byte count: 6.73kb commented, 4.64kb minified, 1.72kb zipped.
<br>Hours count: 3.
<br><a href="http://xem.github.io/js13k19/day3">DEMO</a>
<br>
<h4>Where we're going, we need roads! (and barriers)</h4>
<p>Day 4. In Trackmania, all the races and puzzles are made with blocks on a 3D grid.
<br>The most basic block is a brown square laid on the snowy ground (as you can see in the previous GIF's).
<br>When the players place a square block next to another square block (or any other road block that accepts it), they have the possibility to link them, which creates a continuous portion of road.
<br>The two blocks can also stay independent, and have a gutter of snow between them.
<br>To do this, I made my scene consist of a grid of 10in * 10in (where 1in = 96px).
<br>If an independent square block is placed in a cell, it'll be 9in * 9in, centered, and surrounded by snow.
<br>If two square blocks are linked, the game adds a 1in-wide link between them.
<p><img src="images/js13k19/11.png">
<br>(my tests look like this. Yes, it's ugly, and doesn't have any curves. But we gotta start somewhere!)
<br>
<br>
<p>As you can see, Trackmania also adds solid barriers on the sides of every road portion consisting of a least 2 linked square blocks.
<br>I made an algorithm that checks the links of every block and automatically places little barriers (in the form of vertial, grey, CSS3D planes) where they are necessary.
<br>I adapted it to extend their length in the direction of the link, in order to have a continuous barrier between two linked squares.
<p><img src="images/js13k19/12.png">
<p>Tadaaa! Now the (real) challenge is to make the car collide with these barriers. It may take some time.

<br>Polygon count: 20 for the car, 120 for these 27 road blocks, their links and their barriers.
<br>Byte count: 11.0kb commented, 6.85kb minified, 2.28kb zipped. (wow, that's huge. I mean, for me.)
<br>Hours count: 4.
<br><a href="http://xem.github.io/js13k19/day4">DEMO</a>
<br>
<h4>Cleanup and golf #1</h4>
<p>Day 5. Every few days, I re-read my (anarchic) code base and make it clean, commented and lightly golfed.
<br>I started this 5th day by doing this, and it was quite good, because the minified code fell down to 6.02kb and the zipped code to 2.07kb (and 2.03kb with Advzip).
<br>For the record, to benefit from Advzip extra compression, download Advcomp <a href="https://www.advancemame.it/download">here</a>, put advzip.exe in the same folder than your zip, and execute <b>.\advzip.exe -z -4 -i 1000 .\min.zip</b> in the command line.
<br>(To squeeze a dozen extra bytes at the end of the project, replace 1000 by a bigger number, like 100000. It will take a few minutes to complete though!)
<br>
<br>
<h4>Collisions!</h4>

<p>Let's start with very basic collision detection: considering that all the road blocks are square, and have 0 to 4 barriers on their sides, and considering that the car can only collide from its front side when going forward and from its back side when going backward.
<p><img src="images/js13k19/13.png">
<p>This can be done pretty easily, by computing on which cell the green point is placed (depending on the direction of the car - forward or backward), and if this point is further than a barrier, the car receives an inverted speed, which makes it bounce gently against the wall instead of passing through it. (In terms of code, the car behaves as if all the grey space after a barrier is an obstacle measuring 0.5in).
<p>Two problems appeared quickly.
<br>- The first one is that a back collision with an angle car-wall around 45 degrees will be detected too late, and the car will start clipping through before being stopped. The solution is to compute collisions on the four sides of the car and not only front and back. (I'll do that later though.)
<p><img src="images/js13k19/14.png">
<p>- The second one is that the car would randomly ignore certain barriers when it drives at full speed against it. But all the devs who do 2D or 3D collisions know this problem. If you have an obstacle in front of you, and your speed and alignment makes you stand before the obstacle at one frame and after the obstacle in the next frame, you'll pass through it. The solution (that I implemented) is to perform many little increments at each frame (5 in my case), and test the collisions at each increment. If one of the increments detects a collision, the car gets stopped at this frame, and this solution is effective 100% of the time. You just have to do enough increments to ensure that one increment at max speed is shorter than the size of any obstacle you can encounter on the map.
<p><img src="images/js13k19/15.png">
<br>
<h4>Live debugger</h4>
<p>Of course, all this can't really be coded blindly, nor by watching hundreds of logs in the JS console, that's why I made a textarea that's always visible on screen and that can be updated 30 times per second. It's very handy!
<br>For example, here, the logs indicate which side of the car is tested, if it's out-of-bounds, on which cell it is, and conclude by telling if the car is driving on the snow (if out of bounds), against a barrier (if there's a collision), or nothing (if it's on the road).
<p><img src="images/js13k19/16.gif">

<br>

<h4>Screenshot saturday</h4>
<p>It's time to polish a little (by making a little circuit, adding a start line and a cinematic introduction) and present it to the world:
<blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 5.<br>Here are some news of my CSS3D racing game:<br>- Automatic barriers positioning<br>- Collisions with barriers are working!<br>- Many controls and camera adjustments<br>- Code cleaned up<br>- Polygons so far: 233.<br>- Zip size so far: 2.63kb!<a href="https://twitter.com/hashtag/screenshotsaturday?src=hash&amp;ref_src=twsrc%5Etfw">#screenshotsaturday</a> <a href="https://t.co/Q8e7A3rckb">pic.twitter.com/Q8e7A3rckb</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1162769405845155840?ref_src=twsrc%5Etfw">August 17, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 

<br>
<br>Polygon count: 20 + 213.
<br>Byte count: 17.6kb commented, 7.90kb minified, 2.63kb zipped.
<br>Hours count: 6.
<br><a href="http://xem.github.io/js13k19/day5">DEMO</a>

<br>~~~
<br>

<p>Wait. 213 polygons seem huge for 31 road blocks with barriers... Upon inspection, I realized each barrier was drawn twice or more (once for each link shared with another road block).

<p>Let's remove them altogether and replace them with black borders. Let's also merge every pair of orange and grey planes into a single orange plane with a grey border.
<p>As a result, the polygon count is down to 87 in total!



<br>
<h4>Show your curves!</h4>
<p>Day 6. My friend told me it was nice but too bit pointy... and I agree.
<br>So let's do another algorithm that automatically rounds every road block with two consecutive road links. This is simply made with a 100% CSS border-radius applied to every corner that is opposite to links.

<p><img src="images/js13k19/17.png">
<br>(Before vs. after vs. after with automatic barriers that follow the curves of the road!)

<br>
<h4>Collisions v2</h4>
<p>Now that all blocks are not square anymore, computing collisions is a bit trickier. Actually, it's a lot harder: it took me all the week-end to figure out how to handle collisions on both sides of every barrier, reliably.
<br><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 6. (3.17 kb)<br>It took me most of the week-end, and it&#39;s not totally finished yet, but the road now has curves. And these curves have functioning collisions. (the black lines represent solid barriers).<br><br>I also reduced my polygon budget a lot: 233 =&gt; 87 <a href="https://t.co/3XEObIjQmB">pic.twitter.com/3XEObIjQmB</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1163175569724530690?ref_src=twsrc%5Etfw">August 18, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>To put it simply, the game engine still needs to check straight barriers collisions like before, and allow to cross from a road block to another if they are linked, or between a road block without barrier and the outside (the snow), and vice-versa.
<br>But once it has ensured all these conditions, it also needs to make all the rounded barriers' collisions work as intended.
<br>To do that, each road block with a curve receives an equation (in the form of a JS function) that is able to tell if the car is on the road or outside.
<br>The result of this equation can be used to determine if the car is trying to go from inside to outside (or the opposite) and block it.
<br>"Block it" was the hardest part of the job: after many buggy attempts, I decided to respond to every collisions with a strong opposite force, which makes the car bounce on every wall, with an opposite speed, before being able to continue going forward in the right direction. (Trackmania kinda did that too, so it's fine! Hee hee).

<br>The collision-testing function is 80 lines long, and is executed with the front side of the car as parameter when the car is going forward, and the back side if it's going backward.

<br>
<p>So, about these equations. It turns out, I couldn't find them by myself, so I asked some help on Twitter and Slack.
<br><blockquote class="twitter-tweet"><p lang="en" dir="ltr">Help?<br>Is there an equation that can tell me if a point [x;y] is inside the black area? (the bottom-right side of a circle with a 50px radius, where x and y are between 0 and 50)<a href="https://twitter.com/hashtag/Math?src=hash&amp;ref_src=twsrc%5Etfw">#Math</a> <a href="https://twitter.com/hashtag/Gamedev?src=hash&amp;ref_src=twsrc%5Etfw">#Gamedev</a> <a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> <a href="https://t.co/Gjhf50joxt">pic.twitter.com/Gjhf50joxt</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1163006546785263616?ref_src=twsrc%5Etfw">August 18, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
<br>A lot of people flew to help me with the same approach presented in various ways, but all of them implied to compare the distance from the car to the center of the quarter-circle and the radius. This distance can be computed with Pythagore or directly Math.hypot().
<br>To optimize the CPU usage though, people advised me to avoid quare roots as much as I could, so I obeyed and compared the square of deltaX + the square of deltaY to the square of the radius. Perfect! 👌

<br>

<p>To end this week, I finally separated my project in 8 different files, and added comments everywhere so my future self (and people on Github) will be able to understand what I have been doing!

<br>
<br>Polygon count: 20 + 67.
<br>Byte count: 20.0kb commented, 10.00kb minified, 3.17kb zipped.
<br>Hours count: 9.
<br><a href="http://xem.github.io/js13k19/day6">DEMO</a>


<br>
<hr>
<br>
<h3>Week 2</h3>

<br>
<h4>3D barriers</h4>

<p>Day 7. I used this day to finish debugging the collision detection of last week-end, then I quickly tested to copy the barriers on multiple layers to make them look less flat. It consumed a lot of bytes and polygons, and wasn't looking as nice as I wanted, because of the lack of anti-aliasing when rendering things in CSS3D on Firefox. Moreover, it was super buggy (visually) on Webkit: all the rounded blocks refused to appear at all! So I discarded this test, and without it, Webkit's display is more or less OK.
<br><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 7.<br>I wanted to make the barriers look higher by copying them on two different layers, but I&#39;m not sure it&#39;s worth it.<br>It costs many extra polygons, and the lack of anti-aliasing is kinda problematic... <a href="https://t.co/9iN4PC36zb">pic.twitter.com/9iN4PC36zb</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1163349106473033728?ref_src=twsrc%5Etfw">August 19, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<br>
<p>Hours count: 11.
<br><a href="http://xem.github.io/js13k19/day7">DEMO</a>
<br>
<h4>TRACK EDITOR!</h4>
<p>Day 8. Time to start a big and very important part of the game, the 3D track editor!
<br>Though, very soon, a problem of size appeared: I wanted to display a grid on top of my scene, and dezoom it enough to let the player see the track from above. But when I did that, everything disappeared. The reason was that the scale of my scene was too big for the browser to show at once in CSS3D (I already had this problem when I made LOSSST in 2017: the rooms had to stay very small to avoid being cut or appear glitchy).
<br>Indeed, my grid was comprised of 20 x 20 cells and each cell had a size of 20 x 20 in. (in total: 38400 px x 38400 px).
<br>So the first thing to do was to resize everything: the grid, the car, the road parts, and everything in the JS code that referred to them (camera, display, collision detection).
<br>I also put the base size (100px instead of 20in) in a variable, so it can be adjusted later more easily. With this size, the grid measures 2000px x 2000px and browsers can happily show it!
<br>By the way, I couldn't add 400 polygons in my scene to represent each cell of the grid, it would have made the game extremely slow. Instead, all the lines and columns of the grid are drawn with a repeated linear-gradient, in CSS.

<br><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 8.<br><br>I was tired of writing my roads in JSON...<br>So, It seems like I&#39;m starting a circuit editor.<br>I think it&#39;ll take some days, and a lot of kilobytes, before I have something that looks nice and works! 😬<br>(but here are the first steps anyway) <a href="https://t.co/X8D0RUqtZH">pic.twitter.com/X8D0RUqtZH</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1163896639033135104?ref_src=twsrc%5Etfw">August 20, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<br>As you can see in this screenshot, I also started working on the editor's UI, especially the inventory.
<br>My goal is to make each cell of the inventory display one road block and which quantity of this block is remaining.
<br>I could draw these blocks using SVG or PNG's, but to save bytes, I'll draw each inventory road part directly in CSS3D, by reusing the same model as the one used on the track, but rotated 45° and dezoomed to fit in about 20 x 20 px.
<br>It'll require a good organization to make every block of the game, reusable on the track and in the inventory. But that's doable!
<br>
<p>Byte count: 24.3kb commented (I don't try to minify/zip as long as the code contains logs everywhere)
<br>Hours count: 13.
<br><a href="http://xem.github.io/js13k19/day8">DEMO</a>
<br>
<p>~~~
<br>
<p>Day 9. Today I have a better idea of what I need to do and how. I'm not stuck with CSS3D limits anymore, so I can focus on the editor's features, namely: moving and rotating the grid, moving the "cursor" (the green square) along with the camera, and place road blocks using the cursor.
<br>
<blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 9.<br><br>My project is a mess, there&#39;s code to clean everywhere, but hey! The track editor has a grid that can go up and down and rotate, and a cursor that moves on the grid, and we can start building!<br><br>(you can&#39;t make stuff like that cleanly anyway, can you?) <a href="https://t.co/tXWOaxNOkx">pic.twitter.com/tXWOaxNOkx</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1164237127481253890?ref_src=twsrc%5Etfw">August 21, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
<br>Note that I reused most of Trackmania's keyboard shortcuts: arow keys move the cursor, space key draws a block, del key deletes a removable block. All the rest can be done by clicking on the left menu.
<br>Speaking of keyboard shortcuts: I altered the JS keyboard handler a little to support both space, del and enter keys, and I added extra variables for space and arrow keys to handle them when they're pressed once, or when they're held down, because both cases are treated differently. The pressed key flags are reset after each frame, while the other keep being set until the player releases them. It looks like this:
<pre><code class="lang-js">var s = 0, u = 0, l = 0, d = 0, r = 0; // hold (space / up / left / down / right)
var S = 0, U = 0, L = 0, D = 0, R = 0; // press
var _ = 0, $ = 0; // press suppr key, enter key
onkeydown = onkeyup = z => top['lurdl*d*l_ur*u*s$***'[(z.which+3)%20]] = top['LURDL*D*L_UR*U*S$***'[(z.which+3)%20]] = z.type[5]</code></pre>

<br>
<br>Byte count: 26.0kb commented.
<br>Hours count: 15.
<br><a href="http://xem.github.io/js13k19/day9">DEMO</a>
<br>
<p>~~~
<br>
<p>Day 10. I added the possibility to select blocks in the inventory, rotate them and place them...
<br>I also noticed that my game declares A LOT of global vars, and it's not finished yet!
<br>LOSSST (2017) also had a ton of variables but it wasn't really a problem. The hardest part (for me) was the ton of different CSS variables that I had to rename to 1 char at the last minute. In Back on Track, there will be very few CSS compared to LOSSST. For example, up to now, I only wrote 19 CSS rules, using only 10 CSS classes and 8 ids, which is very few.  
<br><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 10.<br><br>I already have 58 global vars.<br>The 1-char var names A-Z a-z, $ and _ are not enough to hold them all! 😓<br><br>Besides that, the editor now features 3 blocks that can be placed and rotated on the grid. (basic road, start &amp; end flags). They&#39;re not hardcoded anymore! 🥳 <a href="https://t.co/do5V79n5aL">pic.twitter.com/do5V79n5aL</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1164637709597642757?ref_src=twsrc%5Etfw">August 22, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
<br>
<br>Byte count: 28.6kb commented.
<br>Hours count: 16.
<br><a href="http://xem.github.io/js13k19/day10">DEMO</a>
<br>~~~
<br>
<p>Day 11: I started this day by a little enhancement to my editor's menu:
<br>
<p><img src="images/js13k19/18.png">
<br>All the actions that can be done with the keyboard (move cursor, add and remove road blocks) are now none exclusively with the keyboard.
<br>
<br>Moreover, the menu's buttons are now smaller and contain Unicode arrows to be a bit clearer!
<br>It took some time though, because Unicode arrows are a big mess in terms of OS/browser support.
<br>Hopefully, people on Slack helped me find a little subset of all the Unicode Arrows that can be displayed about everywhere, and I tweeted the result <a href="https://twitter.com/MaximeEuziere/status/1164810114710163456">here</a>.
<br>
<pre><code class="lang-js">←→↑↓↔↕↖↗↘↙⤡⤢↚↛↮⟵⟶⟷⇦⇨⇧⇩⬄⇳⬁⬀⬂⬃⬅➡⬆⬇⬉⬈⬊⬋⬌⬍⇠⇢⇡⇣⤌⤍⤎⤏⤑⤐↼⇀↽⇁↿↾⇃⇂⥊⥋⥌⥍⥎⥐⥑⥏⥒⥓⥖⥗⥔⥕⥘⥙⥚⥛⥞⥟⥜⥝⥠⥡⥢⥤⥣⥥⇋⇌⥦⥨⥧⥩⥪⥬⥫⥭⥮⥯⇈⇊⇇⇉⇆⇄⇅⇵⇐⇒⇑⇓⇔⇕⇖⇗⇘⇙⇍⇏⇎⟸⟹⟺⤂⤃⤄⤆⤇⬱⇶⇚⇛⤊⤋⭅⭆⟰⟱⇤⇥⤒↨⤝⤞⤟⤠↤↦↥↧⬶⤅⟻⟼↸⇱⇲⇜⇝⬳⟿↜↝↭⇷⇸⇹⇺⇻⇞⇟⇼↰↱↲↳⬐⬎⬑⬏↴↵↩↪⤣⤤⤥⤦↫↬⤙⤚⤛⤜⥼⥽⥾⥿🔁🔂🔃🔄⤶⤷⤴⤵➩➪➫➬➭➮➯➱⇪⇫⇬⇭⇮⇯➳➵➴➶➸➷➹➙➘➚➾⇰➛➜➔➝➞➟➠➧➨➺➻➼➽↶↷⤾⤿⤸⤺⤹⤻↺↻⟲⟳⥀⥁</code></pre>

<br>Note: these arrows can have very different look across different OS's, and about half of them will break completely the layout of monospace text, but besides that, they work!

<br>
<p>I also saw that the arrow keys became all wrong when the grid (i.e. the whole scene) was rotated 90, 180 or 270°. I improvised a little hack (I mean, a coding trick) to reassign the arrow keys accordingly. It worked on the first try!
<pre><code class="lang-js">// Adjust arrows based on grid angle
for(i = 0; i < gridrz/90; i++){
  [U,R,D,L] = [R,D,L,U]
}</code></pre>

<br>
<p>But let's get back to serious business! Let's plug in the algorithms I made last week: the one that creates links between road blocks, the one that generates the barriers, the one that makes the curves, and the one that generates the equations for every curved block.
<br>It took some hours to have it all behave well, but I did it!
<br><blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 11.<br><br>Guys! Check this out!<br><br>It took me all day and required 4kb of code, but I made this thing work at last:<br><br>My track editor now computes curves and barriers instantly and automatically when I link two road blocks AND when I delete blocks too!🤩<a href="https://twitter.com/hashtag/screenshotsaturday?src=hash&amp;ref_src=twsrc%5Etfw">#screenshotsaturday</a>-1 <a href="https://t.co/4V7dGar652">pic.twitter.com/4V7dGar652</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1164909253884358656?ref_src=twsrc%5Etfw">August 23, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<br>It also took some time to implement the "hold space and move the cursor" mechanic to create a link between two existing blocks, or between an existing block and a new block created at the same time.
<br>I have to admit I'm very happy of this achievement. For the first since this project started, I'm thinking that maybe, if there's no bad surprise, it could probably become something nice.

<br>Fun fact: I made a random tweet explaining that I had lost 30 minutes for a stupid typo in a for loop. This tweet has had more likes and answers than any of my other #js13k tweets this year. I guess it's much more relatable than anything else I'm doing, eh? 🤷

<br><blockquote class="twitter-tweet"><p lang="en" dir="ltr">Guess who lost 30 min because of this line?<a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> <a href="https://t.co/qLVcXqWBxa">pic.twitter.com/qLVcXqWBxa</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1164889745299824643?ref_src=twsrc%5Etfw">August 23, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<br>And to finish this day very well (or not well at all), <a href="https://twitter.com/MaximeEuziere/status/1164986420198592512">I almost lost all my progress of the last 24 hours</a> because of my laptop acting super weird. Lesson learned: PUSH OFTEN, not just once per day!

<br>
<br>Byte count: 32.1kb commented.
<br>Hours count: 19.
<br><a href="http://xem.github.io/js13k19/day11">DEMO</a>

<br>~~~
<br>
<p>Day 12: Today, let's modelize new road parts! I played all the puzzles and races of the snow and desert environments and listed those:
<ul>
<li>start flag (OK)
<li>end flag (OK)
<li>checkpoint flag
<li>flat road (OK)
<li>accelerator
<li>accelerator going down
<!--li>- accelerator going up-->
<li>jumper
<li>short slope
<li>long slope rounded on the bottom, like ◞
<li>long slope rounded on the top, like ◜
<li>road that goes slanted on the side (ignoring it for now because ugh!)
</ul>

<br>
<p>The good news is that it's not a lot. I only have 8 new parts to make.
<br>The less good news is that most of these blocks have special features and limitations that will require a lot of code to implement:
<ul>
<li>all the blocks except the flat roads will have barriers on their front and their back until they're linked to another block.
<li>jumpers can only have one link on their back
<li>slopes and slopes-accelerator are special because they have one link on a certain height's plane and the other link on the upper plane.
<li>and on top of that, long slopes occupy two cells of the grid.
<li>snow, desert and castle environments have different ways to use barriers and prop/supports when the road is higher than the ground, and different ways to link slopes, but we'll see that another day!
</ul>

<br>
<p>But let's start by the 3D models. With CSS3Dframework, it's just a matter of 2 or 3 lines of code per block.
<br>The checkpoint flag is similar to the start and end flags.

<br><p><img src="images/js13k19/19.png">

<br>
<p>The accelerators (flat and slanted) are covered with yellow triangles. This can be done in many different ways (CSS, SVG, Unicode...), but I went with the one that seemed to require the least amount of code and resources: a repeating double linear-gradient in background.
<br>I took an example on <a href="https://leaverou.github.io/css3patterns/#half-rombes">Lea Verou's CSS3 patterns gallery</a>, simplified the code, and applied it to a road block. TADAAA.

<br><p><img src="images/js13k19/20.png">

<br><p>The jumper and slopes are simply made of one or two slanted planes.

<br><p><img src="images/js13k19/21.png">

As I said on day 8, the parts shown in the inventory are the same "3D models" as the ones on the track, but displayed in a tiny space and with a 45° angle. Each slot of the inventory is a separate CSS3D container with a "500px" perspective, similarly to the scene. Here's how the scene and the inventory look with every block represented:

<br><p><img src="images/js13k19/22.png">

<br><p>There's another special place where these road blocks are rendered: the editor's cursor. But it's less tricky here because it's rendered in the scene with all the other blocks. It's just that it can be replaced with any other block instantly when clicking an inventory item.

<br><p>Oh, also: as I said <a href="https://twitter.com/MaximeEuziere/status/1165311745524752387">here on Twitter</a>, this whole scene only uses 61 polygons, which is very reasonable!

<br>
<br>Byte count: 35.2kb commented.
<br>Hours count: 21.
<br><a href="http://xem.github.io/js13k19/day12">DEMO</a>


<br>~~~
<br>
<p>Day 13: During the next days, my goal is to make all these new blocks connectable with each other. All the blocks except the basic road square don't need to be manually linked to their neighbours: when you place these blocks on the scene, if a compatible block is already present at one of their link points, and has the right orientation, the link will be automatic. And inversely, a new basic road block will automatically be linked to a neighbour non-basic road block if both are linkable together.

<br>
<p>The most annoying part here is to organize the data. each cell of the 3D world must know a ton of information:
<ul>
<li>if it's free or occupied by a road block or a prop,
<li>if it can make links on its up/right/down/left side and at which coordinates,
<li>if it has a link on its up/right/down/left side,
<li>if it is flat or rounded on its up/right/down/left side,
<li>if it has a barrier on its up/right/down/left side,
<li>the coordinates of its surrogate block in case of double block
<li>its angle (0 90, 180 or 270),
<li>and its out-of-bounds equation.

<pre><code class="lang-js">// Example data for a basic road block (id #0) that is rounded on the bottom left and linked to other blocks on its up and right sides.

space[x][y][z] = {
  free: 0,
  item_id: 0,
  linkable: { u: [x, y-1, z], r: [x+1, y, z], d: [x, y+1, z], l: [x-1, y, z]},
  links: { u: 1, r: 1, d: 0, l: 0 },
  flat: { u: 1, r: 1, d: 0, l: 0 },
  barriers: { u: 0, r: 0, d: 1, l: 1 },
  surrogate: 0,
  angle: 0,
  equation: `Math.hypot(x-${x},y-${y},z-${z}>size*.8`
}</code></pre>

<br><p>Every time a block is added or removed in the scene, all these pieces of information must be computed or updated, for that block, and for all its neighbours. (plus the neighbours on the higher level if it's a slope).

<br><p>I cleaned the code and the data to be able to do this well, and since it's saturday, let's take a moment to minimize and zip what we have so far:

<br>

<blockquote class="twitter-tweet" data-conversation="none"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/js13k?src=hash&amp;ref_src=twsrc%5Etfw">#js13k</a> day 13.<br>I&#39;m optimizing the organization of the editor&#39;s code and my data models.<br>It takes a while to figure out the best solution.<br>Anyway, the fun fact is that my minified JS is exactly 13kb!<br>And my zip is only 4.25kb, after all the things I&#39;ve added these past few days🤯 <a href="https://t.co/BlfRI7mTmU">pic.twitter.com/BlfRI7mTmU</a></p>&mdash; xem 🔵‏ (@MaximeEuziere) <a href="https://twitter.com/MaximeEuziere/status/1165729472773087232?ref_src=twsrc%5Etfw">August 25, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<br>Byte count: 33.9kb commented, 4.25kb zipped!
<br>Hours count: 23.
<br><a href="http://xem.github.io/js13k19/day13">DEMO</a>

<!--br>~~~
<br>
<p>Day 14: lundi

<br>~~~
<br>
<p>Day 15: mardi-->


<br>
<br>
<hr>
<br>
<h3>Week 3</h3>
...
<br>
<br>
<hr>
<br>
<h3>Week 4</h3>
...
<br>
<br>
<hr>
<br>
<h3>Week 5</h3>
...
<br>
<br>
<hr>
<br>
<h3>Conclusion</h3>

<p>

<p><b>Xem</b>

</div>

</main>

</div>

<footer></footer>

<script src="../ui.js"></script>
<script>
header();
footer();
menu();
</script>

</body>
</html>