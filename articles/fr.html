<!doctype html>
<html>
<head>
  <meta charset=utf-8>
  <link rel=stylesheet href="../style.css">
  <title>Maxime Euzière</title>
</head>
<body>
  <div class=menu>
    <div class=header>
      <h1>Maxime Euzière</h1>
      Veille et expériences front-end
      <br>
      HTML / CSS / JS
      <br>
      <br>
      <a href="../fr.html">Accueil</a>
      <a href="../articles/fr.html" class=active>Articles</a>
      <a href="../techwatch/fr.html">Veille techno</a>
      <a href="../projects/fr.html">Projets / expériences</a>
      <a href="../talks/fr.html">Présentations</a>
      <a href="../golfing/fr.html">JS Code golfing</a>
    </div>
    <div class=footer>© 2014 - <a href="../cv/cv-fr.html" target=_blank>CV</a> - <a href=en.html><img src="../english.png" alt="English version" title="English version" class=pulse></a></div>
  </div>
  <div class=body>
<div class=section>
	<h2>Les "getElementById" implicites</h2>
	<h3>octobre 2013</h3>
	<div id=getelementbyid style="xdisplay: none">
		<p>Quelle fonction JavaScript est la plus utile, et la plus embêtante à écrire? <b>document.getElementById()</b>, bien sûr! C'est tellement utile, et tellement long que toute librairie JS digne de ce nom crée un alias (généralement <b>$()</b>) pour pouvoir l'appeler facilement.</p>
    <p>Mais saviez-vous qu'on n'a, bien souvent, même pas besoin de l'appeler? En effet, tous les navigateurs qu'on peut trouver en circulation aujourd'hui (y compris IE6+) permettent d'accéder à un élément HTML en utilisant directement son <b>id</b> comme une variable globale! C'est un fonctionnement complètement non-standard, mais qui a le bon goût de marcher partout, et extrêmement bien.</p>
    <pre>&lt;div id="monId">&lt;/div>
&lt;script>
  alert(monId);                           // --> [object HTMLDivElement]
  alert(monId.id);                        // --> "monId"
  alert(window.monId.id);                 // --> "monId"
  alert(this.monId.id);                   // --> "monId"
  alert(self.monId.id);                   // --> "monId"
  alert('monId' in window);               // --> true
  alert(window.hasOwnProperty("monId"));  // --> true
&lt;/script></pre>
    <p>"monId" est bien une propriété window, mais il n'est pas énumérable, autrement dit, on ne tombera pas dessus si on fait une boucle ou un console.dir():</p>
    <pre>
// On affiche le contenu de window:
console.dir(window);                      // monId n'est pas présent.

// On itère sur les propriétés de window:
var present = false;
for(var i in window){
  if(i == 'monId'){
    present = true;
  }
}
alert(present);                           // --> false
    </pre>
    <p>J'ai fait quelques expériences avec cette "fonctionnalité", et j'ai découvert des choses rigolotes:</p>
    <p><b>Un id implicite ne peut pas avoir le même nom qu'un mot-clé JavaScript protégé</b></p>
    <pre>&lt;div id=function>&lt;/div>
&lt;script>alert(function) // SyntaxError: Unexpected token )&lt;/script></pre>
		<br>
    <p><b>Un getElementById implicite ne peut pas écraser une variable globale native, par exemple window.screen:</b></p>
    <pre>&lt;div id=screen><&lt;/div>

&lt;script>
  screen.innerHTML = "screen";          // --> rien ne se passe
  alert(screen);                        // --> [object Screen]
&lt;/script></pre>
		<br>
    <p><b>Il ne peut pas non plus écraser une variable globale définie auparavant:</b></p>
    <pre>&lt;script>
  global0 = 1;
&lt;/script>

&lt;div id=global0><&lt;/div>

&lt;script>
  global0.innerHTML = "global0";        // --> rien ne se passe
  alert(global0);                       // --> 1
&lt;/script></pre>
		<br>
    <p><b>Une variable globale définie avec le préfixe "window." peut écraser un getElementById implicite</b></p>
    <pre>&lt;div id=global1>&lt;/div>

&lt;script>
  global1.innerHTML = "global1";        // --> la div contient le texte "global1" 
  console.log(global1);                 // --> [object HTMLDivElement]
  window.global1 = 1;                   // Essayons d'écraser global1
  console.log(global1);                 // --> 1
&lt;/script></pre>
    <br>
    <p><b>Si on essaye d'écraser un getElementById implicite avec une variable globale définie sans aucun préfixe, voici ce qui se passe:</b></p>
    <pre>&lt;div id=global2>&lt;/div>

&lt;script>
  global2.innerHTML = "global2";        // --> la div contient le texte "global2" 
  try{global2 = 1}                      // Essayons d'écraser global2
  catch(e){alert(e)}                    // --> TypeError sur IE < 9 / pas d'erreur ailleurs
  console.log(global2);                 // --> [object HTMLDivElement] sur IE < 9 / 1 ailleurs
&lt;/script></pre>
    <br>
    <p><b>Et enfin, si on essaye d'écraser un getElementById implicite avec une variable globale définie avec un "var", voici ce qui se passe:</b></p>
    <pre>&lt;div id=global3>&lt;/div>

&lt;script>
  global3.innerHTML = "global3";        // --> Uncaught TypeError: Cannot set property 'innerHTML' of undefined
  console.log(global3);                 // --> undefined
  var global3 = 1;                      // --> Essayons d'écraser global3
  console.log(global3);                 // --> 1
&lt;/script></pre>
    <br>
    <p>Dans ce cas-là, la présence du mot-clé "var" à la ligne 3 change l'ordre dans lequel le code JS est parsé, et ça fait bugger les lignes 1 et 2.</p>
    <hr>
    <p>En conclusion, cette astuce est pratique dans quelques cas particuliers où on souhaite ni installer une lourde librairie, ni appeler la longue fonction <b>document.getElementById()</b>, notamment dans des épreuves de code golfing. Mais dans le cadre professionnel, il est plus prudent de continuer à utiliser les bonnes vieilles méthodes natives car les pièges des <b>document.getElementById</b> implicites sont nombreux, et ça peut mener à des heures de débogage...</p>
		<br>
		A bientôt!
		<br>
		<b>@MaximeEuziere</b>
	</div>
	<!--button onclick="document.getElementById('getelementbyid').style.display='block';this.style.display='none'">Lire</button-->
</div>

<div class=section>
	<h2>Les joies du text-shadow... sur IE.</h2>
	<h3>septembre 2013</h3>
	<div id=text-shadow style="display: none">
		<p>On ne présente plus <b>text-shadow</b>, cette propriété CSS3 permettant d'appliquer une ombre à un texte.<br>(voir: <a href="http://www.w3.org/TR/css3-text/#text-shadow" target=_blank>les specs</a>, <a href="https://developer.mozilla.org/fr/docs/CSS/text-shadow" target=-blank>la page MDN</a>)</p>
		<p>Plusieurs navigateurs ont des petits soucis d'implémentation, mais les plus notables sont, bien évidemment, les vieux IE. Plus précisément, IE &lt; 10.</p>
		<p>Ceux-ci ont toutefois accès à des "filtres" créés par Microsoft, et qui permettant de produire un effet similaire.<br>Et parfois, on n'a pas le choix, il faut s'en servir. Voici comment faire.</p>
		<p>Deux filtres permettent de simuler des ombres: Shadow et Glow.</p>
		<p><b>Voici la version "Shadow":</b></p>
		<p>CSS:</p>
		<pre style="white-space: nowrap; overflow: auto">h1 {
<br>
&nbsp; text-shadow: 2px 2px 3px #ff0000; /* IE10+, Firefox 3.5+, Opera 9.5+, Chrome, Safari, et tous avigateurs mobiles */
<br>
&nbsp; filter:progid:DXImageTransform.Microsoft.Shadow(color='#ff0000', Direction=135, Strength=3); zoom: 1; /* IE 6-9 */
<br>
}</pre>
		<p>HTML:</p>
		<pre>&lt;h1>Titre ombré&lt;/h1></pre>
		<p>Rendu:</p>
  	<style class=hidden>h1.ombre1 { text-shadow: 2px 2px 3px #ff0000; filter:progid:DXImageTransform.Microsoft.Shadow(color='#ff0000', Direction=135, Strength=3); zoom: 1; }</style>
		<div class=demo>
			<h1 class=ombre1>Titre ombré</h1>
		</div>
		<p>Si vous regardez cette magnifique démo sur un vieux IE (ou sur IE10 en mode vieux IE) vous verrez bien une ombre. Mais vous verrez aussi que le texte est devenu tout pixellisé, et il n'y a hélas aucun moyen de corriger cela.</p>
		<p>Il est à noter que "Direction" s'exprime en degrés (par exemple, 0 = haut, 90 = droite, 180 = bas, 270 = gauche) et "Strength" correspond vaguement à l'étalement de l'ombre. (en réalité, ça ressemble plus à un effet de profondeur qu'à une ombre)</p>
		<p><b>Et voici la version "Glow"</b></p>
		<p>CSS:</p>
		<pre style="white-space: nowrap; overflow: auto">h1 {
<br>
&nbsp; text-shadow: 0px 0px 1px #ff0000; /* Bons navigateurs */
<br>
&nbsp; filter: glow(color=#ff0000,strength=3); zoom: 1; /* IE 6-9 */
<br>
}</pre>
		<p>HTML:</p>
		<pre>&lt;h1>Titre entouré d'ombre&lt;/h1></pre>
		<p>Rendu:</p>
  	<style class=hidden>.ombre2 { text-shadow: 0px 0px 3px #ff0000; filter: glow(color=#ff0000,strength=1); zoom: 1; }</style>
		<div class=demo>
			<h1 class=ombre2>Titre entouré d'ombre</h1>
		</div>
		<p>Le filtre Glow permet plutôt de créer un halo autour du texte. Cela dit, c'est bien moche sur IE. (oui, j'ai un peu exégéré avec mon texte en gras et mes ombres en rouge, il y a moyen de faire quelque chose qui soit... passable.)</p>
		<hr>
		<p></p>Il est à noter que les filters peuvent être additionés, tout comme les text-shadow CSS3. C'est pratique, notamment pour obtenir un effet à la "text-stroke" (pour dessiner le contour des lettres).</p>
		<pre style="white-space: nowrap; overflow: auto">h1 {
<br>
&nbsp; text-shadow: 1px 1px 1px #ff0000, 1px -1px 1px #00ff00, -1px -1px 1px #0000ff, 1px 1px 1px #f0000f; /* Bons navigateurs */
<br>
&nbsp; filter: progid:DXImageTransform.Microsoft.Shadow(color='#ff0000', Direction=0, Strength=1), progid:DXImageTransform.Microsoft.Shadow(color='#00ff00', Direction=90, Strength=1), progid:DXImageTransform.Microsoft.Shadow(color='#0000ff', Direction=180, Strength=1), progid:DXImageTransform.Microsoft.Shadow(color='#f0000f', Direction=270, Strength=1); zoom: 1; /* IE 6-9 */
<br>
}</pre>
		<p>HTML:</p>
		<pre>&lt;h1>Titre avec plusieurs ombres&lt;/h1></pre>
		<p>Rendu:</p>
  	<style class=hidden>.ombre3 { text-shadow: 1px 1px 1px #ff0000, 1px -1px 1px #00ff00, -1px -1px 1px #0000ff, 1px 1px 1px #f0000f; filter: progid:DXImageTransform.Microsoft.Shadow(color='#ff0000', Direction=0, Strength=1), progid:DXImageTransform.Microsoft.Shadow(color='#00ff00', Direction=90, Strength=1), progid:DXImageTransform.Microsoft.Shadow(color='#0000ff', Direction=180, Strength=1), progid:DXImageTransform.Microsoft.Shadow(color='#f0000f', Direction=270, Strength=1); zoom: 1;}</style>
		<div class=demo>
			<h1 class=ombre3>Titre avec plusieurs ombres</h1>
		</div>
		<p>Cela dit, c'est très verbeux, et également très moche sur IE si on s'en sert mal.</p>
		<hr>
		<p>A part ça, j'ai un petit bug bonus, en exclusivité:</p>
		<p>Ces filtres ne marchent que sur les blocs, et pas sur les éléments inline.</p>
		<p>Autrement dit, si on vous demande de mettre des ombres sur des <b>span</b>, la seule solution sera d'écrire le non-sens suivant: <b>span { display: block }</b> ... et prier pour que ça ne casse pas toute votre page...</p>
		<br>
		<br>
		A bientôt!
		<br>
		<b>@MaximeEuziere</b>
	</div>
	<button onclick="document.getElementById('text-shadow').style.display='block';this.style.display='none'">Lire</button>
</div>
	
	
<div class=section>
	<h2>Les listes ordonnées et non-ordonnées</h2>
	<h3>août 2013</h3>
	<div id=listes style="display: none">
		<p>Les listes HTML... tout le monde les connaît par coeur: elles existent depuis les toutes premières versions d'HTML et XHTML, et sont restées quasiment inchangées jusqu'à aujourd'hui. Elles fonctionnent d'ailleurs sur tous les navigateurs.</p>
		<p>Etudions tout d'abord leur HTML.<br><b>&lt;ul></b> signifie "unordered list", <b>&lt;ol></b> signifie "ordered list", et <b>&lt;li></b> signifie "list item".<br>Voici leur écriture la plus simple: (vous noterez que les &lt;/li> sont optionnels)</p>
		<p><b>Démo:</b></p>
		<pre>&lt;ul>
  &lt;li>Element 1
  &lt;li>Element 2
  &lt;li>Element 3
&lt;/ul>

&lt;ol>
  &lt;li>Element 1
  &lt;li>Element 2
  &lt;li>Element 3
&lt;/ol></pre>
		Ce qui donne:
		<div class=demo>
			<ul>
				<li>Element 1
				<li>Element 2
				<li>Element 3
			</ul>
			<br>
			<ol>
				<li>Element 1
				<li>Element 2
				<li>Element 3
			<ol>
		</div>
		<p>Les <b>li</b> peuvent à leur tour contenir des sous-listes <b>ul</b> ou <b>ol</b>. (mais nous en reparlerons plus tard)</p>
		<p>Les listes ont également des attributs spécifiques:</p>
		<ul>
			<li>L'<b>&lt;ul></b> (et ses <b>&lt;li></b>) peuvent avoir un attribut type, ayant comme valeur "circle", "square" ou "disc". Cela permet de changer leurs puces (par défaut à "circle").</li>
			<li>L'<b>&lt;ol></b> (et ses <b>&lt;li></b>) peuvent aussi avoir un attribut type, ayant comme valeur "A", "a", "I", "i", "1". Cela permet de changer leurs numérotations (par défaut à "1").</li>
			<li>L'attribut type est toutefois à éviter, il vaut mieux faire ces modifications avec du CSS. (on va en reparler)</li>
			<li>L'<b>&lt;ol></b> peut avoir un attribut "start" disant où doit commencer la numérotation, et ses <b>&lt;li></b> peuvent avoir un attribut "value" changeant le numéro de l'élément courant, et de ceux qui suivent. (et c'est compatible IE6+)</li>
		</ul>
		<p><b>Démo:</b></p>
		<pre>&lt;ol start="10">
  &lt;li>Element 10
  &lt;li>Element 11
  &lt;li>Element 12
  &lt;li value="20">Element 20
  &lt;li>Element 21
  &lt;li>Element 22
  &lt;li value="5">Element 5
  &lt;li>Element 6
  &lt;li>Element 7
&lt;/ol></pre>
		Ce qui donne:
		<div class=demo>
			<ol start="10">
				<li>Element 10
				<li>Element 11
				<li>Element 12
				<li value="20">Element 20
				<li>Element 21
				<li>Element 22
				<li value="5">Element 5
				<li>Element 6
				<li>Element 7
			</ol>
		</div>
		<ul>
			<li>Et enfin, <b>&lt;ol></b> peut avoir un attribut "reversed" (apparu en HTML5) servant à compter à l'envers (de bas en haut). Mais vu qu'il ne fonctionne pas sur IE &lt; 11, il est préférable de mettre directement des "value" décroissantes à chaque <b>&lt;li></b> pour obtenir cet effet.</li>
		</ul>
		<hr>
		<p>Voyons maintenant leur code CSS par défaut, et les propriétés CSS qui leurs sont dédiées:</p>
		<p><b>&lt;ul></b> et <b>&lt;ol></b> sont des blocs classiques (display: block). Ils ont un padding-left qui varie selon les navigateurs (environ 40px). Les puces sont incluses dans ce padding et ne peuvent pas être sélectionnées à la souris, en tant que texte.</p>
		<p>L'<b>&lt;ul></b> a des puces en forme de disque (list-style: disc outside none).</p>
		<p>L'<b>&lt;ol></b> a des numéros en face de chaque élément (list-style: decimal outside none).</p>
		<p>Les <b>&lt;li></b> ont un affichage particulier (display: list-item), quasiment identique à du display: block. Ils ont également un list-style hérité de leur parent, mais qui peut être surchargé individuellement.</p>
		<p>
		La propriété CSS <b>list-style</b> est une écriture shorthand qui peut être utilisée pour fixer trois paramètres:<br>
		<ul>
			<li><b>list-style-type</b> (pouvant avoir <a href="https://developer.mozilla.org/fr/docs/CSS/list-style-type" target=_blank>une multitude de valeurs</a>),</li>
			<li><b>list-style-position</b> (qui peut avoir comme valeur "inside", "outside" et "inherit", inside leur permettant de contenir leurs puces, au lieu de les laisser dans le padding du parent.)</li>
			<li><b>list-style-image</b>, qui est par défaut à "none", mais qu'on peut remplacer par l'url d'une image. Si l'URL est invalide (ou si l'image est absente), c'est le list-style-type (disque, décimal, ...) qui sera utilisé comme fallback.</li>
		</ul>
		</p>
		<hr>
		<p>Voyons maintenant les différents problèmes que les listes peuvent nous poser:</p>
		<p>&nbsp;&bull;
			Si vous appliquez un <a href="http://meyerweb.com/eric/tools/css/reset/" target=_blank>CSS reset</a> à votre page, celui-ci va supprimer les paddings des <b>ul</b> et des <b>ol</b>, ce qui cachera leurs puces.
			<br>
			<b>Solution 1</b>: mettre les puces dans les <b>li</b> grâce à cette règle:
			<pre>ul, ol { list-style-position: inside }</pre>
			Les puces réapparaissent, mais on perd l'indentation des listes imbriquées.
			<br>
			<pre>&lt;ul>
  &lt;li>liste
  &lt;li>liste
    &lt;ol>
      &lt;li>sous-liste
      &lt;li>sous-liste
    &lt;/ol>
&lt;/ul></pre>
			<div class=demo>
				<ul style="list-style-position: inside; margin: 0; padding: 0;">
				<li style="margin: 0; padding: 0;">liste
				<li style="margin: 0; padding: 0;">liste
					<ol style="list-style-position: inside; margin: 0; padding: 0; display: block">
						<li style="margin: 0; padding: 0;">sous-liste
						<li style="margin: 0; padding: 0;">sous-liste
					</ol>
				</ul>
			</div>

			<b>Solution 2 (la bonne)</b>: ne pas toucher à la position des puces, mais remettre un padding-left aux listes, comme ceci:
			<br>
			<pre>ul, ol { padding-left: 2em }</pre>
			Ce qui donne:
			<div class=demo>
				<ul>
				<li>liste
				<li>liste
					<ol style="display:block">
						<li>sous-liste</li>
						<li>sous-liste</li>
					</ol>
				</ul>
			</div>
			En effet, les padding-left s'additionnent, ce qui permet à la sous-liste d'être plus indentée que sa liste parente. 
		</p>
		<p>
		&nbsp;&bull; Si on imbrique plusieurs listes ordonnées, leurs numérotations seront identiques (notation décimale). Une bonne pratique typographique consiste à faire ceci:
			<pre>ol { list-style-type: decimal }
ol ol { list-style: upper-alpha }
ol ol ol { list-style:  lower-roman }
ol ol ol ol { list-style: lower-alpha }</pre>
			<br>
			Ce qui permet d'avoir des listes imbriquées aussi jolies que ceci, quand quatre listes ordonnées sont imbriquées:
			<div class=demo>
			<ol>
				<li>level 1</li>
				<li>item</li>
				<li>item</li>
				<li><ol>
						<li>level 2</li>
						<li>item</li>
						<li>item</li>
						<li><ol>
								<li>level 3</li>
								<li>item</li>
								<li>item</li>
								<li><ol>
										<li>level 4</li>
										<li>item</li>
										<li>item</li>
									</ol>
							</ol>
					</ol>
			</ol>
			</div>
		</p>
		<p>
		&nbsp;&bull;
				Les CSS resets mettent généralement un vertical-align: baseline et un line-height: 1.5em à tous les éléments de la page, et ça pose problème sur IE &lt; 8 dans le cas où on a des listes imbriquées.
				<br>
				En effet, en regardant la liste suivante sur IE &lt; 8, vous verrez les numéros "tomber" tout en bas des sous-listes, et les puces seront mal alignées avec les textes en face.
				<br>
				<div class=demo>
				<ol>
					<li>level 1</li>
					<li>item</li>
					<li>item</li>
					<li style="vertical-align: baseline"><ol>
							<li>level 2</li>
							<li>item</li>
							<li>item</li>
							<li style="vertical-align: baseline"><ol>
									<li>level 3</li>
									<li>item</li>
									<li>item</li>
									<li style="vertical-align: baseline"><ol>
											<li>level 4</li>
											<li>item</li>
											<li>item</li>
										</ol>
								</ol>
						</ol>
				</ol>
			</div>
			<p>Pour corriger les puces qui "tombent", utilisez ce CSS:</p>
			<pre>ol, ul, li { vertical-align: top }</pre>
			<p>Pour corriger l'alignement entre les puces et le texte, il n'y a pas de solution miracle, mais cinq approches possibles:</p>
			<ul>
				<li>Soit considérer que quelques pixels de décalage sur IE &lt; 8, c'est pas grave, et ne rien faire.</li>
				<li>Soit mettre un line-height à "1em" sur toute la page.</li>
				<li>Soit laisser le line-height par défaut à "1.5em", mais mettre le line-height des &lt;li> à "1em" et leur padding à "0.25em 0", ce qui fera quasiment le même effet qu'un line-height: 1.5em, l'inconvénient étant que si le texte d'un &lt;li> s'étale sur deux lignes, ces lignes seront très collées.</li>
				<li>Soit remplacer la puce par une image qui a l'apparence d'une puce, mais décalée de quelques pixels vers le bas.</li>
				<li>
					Soit (et c'est la solution que je préconise) mettre un élément (par exemple &lt;span>) dans chaque &lt;li>, et appliquer ce style:
					<pre>li span { *position: relative; *top: -0.5em }</pre>
					Ce qui donne:
					<div class=demo>
						<ul>
							<li><span style="*position: relative; *top: -0.5em">Item 1</span></li>
							<li><span style="*position: relative; *top: -0.5em">Item 2</span></li>
							<li><span style="*position: relative; *top: -0.5em">Item 3</span></li>
						</ul>
					</div>
				</li>
			</ul>
			<p>Il y a par contre un bug présent sur tous les derniers IE parus (sauf IE6 et 7!), et que vous pouvez observer ici:</p>
			<div class=demo>
			<ol>
				<li>level 1</li>
				<li>item</li>
				<li>item</li>
				<li><ol style="display: block">
						<li>level 2</li>
						<li>item</li>
						<li>item</li>
						<li><ol style="display: block">
								<li>level 3</li>
								<li>item</li>
								<li>item</li>
								<li><ol style="display: block">
										<li>level 4</li>
										<li>item</li>
										<li>item</li>
									</ol>
							</ol>
					</ol>
			</ol>
			</div>
			<p>Chaque sous-liste est décalée vers le bas. Ce n'est pas une marge ni un padding, c'est un bug d'IE. Pour s'en débarasser, vous pouvez soit mettre les sous-listes en float:left (ce qui pose des problèmes de flot), soit (et c'est la bonne solution) les mettre en inline-block:</p>
			<pre>li ul, li ol { display: inline-block }</pre>
			<p>Avec ça, tout rentre dans l'ordre.</p>
			<p>D'autres bugs IE6/7 relatfs aux listes, et leurs solutions, sont détaillés <a href="http://stylisticweb.com/design-tutorials/15-ie6-bugs-and-simple-solutions" target=_blank>ici</a>, mais je n'en parlerai pas car ils apparaissent dans des cas trop spécifiques.</p>
			<hr>
			<p>Parlons plutôt des choses originales qu'on peut faire avec des listes HTML:</p>
			<ul>
				<li>
					Un &lt;li> peut ne pas avoir d'&lt;ol> ou d'&lt;ul> autour. Il sera alors précédé d'un cercle (et ce, sur tous les navigateurs).
				</li>
				<li>
					Un &lt;ul> / &lt;ol> peut contenir autre choses que des &lt;li>. (des éléments HTML ou du texte). Ceux-ci seront dénués de puces ou de numéros.
				</li>
				<li>
					Il existe des moyens simples pour faire en sorte qu'une liste s'affiche sur plusieurs colonnes.<br><a href="http://alistapart.com/article/multicolumnlists" target=_blank>Cet article</a> traite ce sujet de façon exhaustive.
				</li>
				<li>
					Une liste peut ressembler à une arborescence avec une image de 1px et du CSS ingénieux: <a href="http://css-tricks.com/style-a-list-with-one-pixel/" target=_blank>voyez plutôt</a>.
				</li>
				<li>
					Les &lt;li> peuvent avoir des caractères unicode comme puces, grâce au CSS3 (et ça marche sur IE8+):
					<pre>li { list-style: none }
li:before { content: ">>"; margin:0 1em 0 -3em;  }</pre>
				Ce qui donne:
					<style style="display: none">
					.custombullet li { list-style: none }
					.custombullet li:before { content: ">>"; margin: 0 1em 0 -3em; }
					</style>
					<div class=demo>
						<ul class=custombullet>
							<li>Item 1</li>
							<li>Item 2</li>
							<li>Item 3</li>
						</ul>
					</div>
				</li>
			</ul>
			<p>Sur ce, je m'arrête là, et je vous invite à jeter un oeil à <a href="//xem.github.io/Blog" target="_blank">mon dernier projet, Basis</a>: un point de départ (ou "boilerplate", comme on dit outre-France) pour faire des pages HTML/CSS/JS, avec un CSS reset maison qui inclut toutes ces techniques pour bien gérer les listes (imbriquées) sur tous les navigateurs.</p>
			<br>
			<br>
			A bientôt!
			<br>
			<b>@MaximeEuziere</b>
	</div>
	<button onclick="document.getElementById('listes').style.display='block';this.style.display='none'">Lire</button>
</div>

<div class=section>
	<h2>L'attribut contenteditable en HTML5</h2>
	<h3>juillet 2013</h3>
	<div id=contenteditable style="display: none">
		<p>L'attribut <b>contenteditable</b> permet de rendre le contenu de n'importe quel élément HTML éditable avec le clavier et/ou la souris.</p>
		<p>
		Cet attribut fait partie des <a href="http://dev.w3.org/html5/markup/global-attributes.html">attributs globaux HTML5</a>, ce qui signifie qu'il peut potentiellement être appliqué à tous les éléments HTML5.
		<br>
		Il fait également partie de ces fonctionnalités qui ont existé dans les navigateurs bien avant d'avoir été standardisées par le W3C.
		<br>
		En effet, <a href="http://caniuse.com/contenteditable">on retrouve cet attribut</a> sur des navigateurs aussi anciens qu'IE 5 et Firefox 3! C'est d'ailleurs Microsoft qui l'a créé.
		</p>
		<p>
		Pour l'utiliser, rien de plus simple: tout comme vous pouvez appliquer un attribut <b>id</b> ou <b>class</b> à un élément HTML, vous pouvez utiliser <b>contenteditable="true"</b>, ou tout simplement <b>contenteditable</b>.
		<br>
		Il est à noter que cet attribut est hérité par défaut. La valeur <b>contenteditable="inherit"</b> est donc complètement inutile.
		<br>
		Par contre, si vous voulez rendre un élément éditable mais pas ses descendants, ceux-ci doivent avoir <b>contenteditable="false"</b>.
		</p>
		<p contenteditable><b>Exemple:</b> cliquer sur ce paragraphe pour éditer le texte qui s'y trouve.</p>
		<hr>
		<p>Voici maintenant la liste des trucs dingues concernant <b>contenteditable</b>:</p>
		<ul>
			<li>
				Comme on l'a vu plus haut, on peut rendre un élément non éditable alors que son parent est éditable. L'élément non éditable pourra toutefois être sélectionné, déplacé et supprimé.
				<p contenteditable><b>Exemple:</b> Dans ce paragraphe éditable, on ne peut pas éditer <b contenteditable="false">ce texte en gras</b> mais on peut le supprimer et le déplacer à l'aide de la souris.</p>
				Sur Firefox, on ne peut pas déplacer du texte d'un bloc éditable à un autre bloc éditable. C'est un bug.
			</li>
			<li>
				Firefox permet de redimensionner les images qui ont l'attribut <b>contenteditable</b> (ou qui en héritent)<br><br>
				<b>Exemple:</b><br>
				<p contenteditable> Cliquez sur cette image <img src="http://placehold.it/200x50" style="vertical-align: middle"> pour la redimensionner.</p>
			</li>
			<li>
				On peut insérer n'importe quel code HTML dans un élément éditable
				<div contenteditable><b>Exemple:</b> copiez-collez ci-dessous<br><br>- Le contenu d'une autre page Web:<br><br><br><br>- Le contenu d'un document Word ou Excel:<br><br><br><br></div>
			</li>
			<li>
				Grâce à cet attribut, on peut faire des éditeurs WYSIWYG ultra-complets, comme <a href="http://ckeditor.com/demo#full">CKEditor</a>.
			</li>
			<li>
				On peut aussi avoir accès à un bloc-notes d'appoint en tapant <b>data:text/html, &lt;html contenteditable></b> dans la barre d'adresse de son navigateur (ou en cliquant <a href="data:text/html, <html contenteditable>" target="_blank">ici</a>).
				On doit cette astuce à <a href="https://coderwall.com/p/lhsrcq">Jose Jesus Perez Aguinaga</a>.
				Vous trouverez <a href="https://news.ycombinator.com/item?id=5135194" target="_blank">ici</a> de nombreuses variations de ce bloc-botes. 
			</li>
			<li>Rendre un élément <b>style</b> visible et éditable peut mener à un éditeur auto-récursif assez dingue, étant donné que vous pouvez editer en direct le style du bloc dans lequel vous écrivez.<br>Essayez ci-dessous:<br>
				<style spellcheck="false" contenteditable>style[contenteditable] {
	display: block;          /* rendre vidible les blocs <style> */
	white-space: pre;        /* présentation */
	font-family: monospace;  /* typographie */
	background: #ddeeff;     /* couleur de fond */
	color: #112233;          /* couleur de texte */
}</style>
			</li>
			<li>
				On peut aussi rendre les éléments <b>script</b> visibles et éditables (en voici un exemple). Toutefois, le code JavaScript n'est pas réexécuté automatiquement à chaque modification.<br>
				<script contenteditable>console.log("Log unique");</script>
				<br>
				(ouvrez votre console F12 pour voir ce message)
				<br>
				Mais JavaScript, justement, permet de détecter les changements qui ont lieu dans un élément <b>script</b> et exécuter son contenu.<br>
				Attention toutefois, évaluer du code JS venant de vos visiteurs peut être dangereux. L'exemple qui suit n'est qu'un proof of concept!<br> 
				<script id="js" contenteditable>// Ce bloc script a l'id "js".
var js = document.getElementById("js");
js.onkeyup = function(){
	eval(js.innerText);
}
console.log("Log à chaque modification");</script>
				<br>
				Cela fonctionne très bien sur Chrome et IE 10. Firefox et IE9 sont hélas capricieux et il est compliqué de leur faire exécuter du code JS à chaque modification d'un élément <b>script</b>... A vrai dire, je ne suis même pas sûr que ça soit possible. Faute de mieux, on peut continuer à utiliser des textarea, qui sont nativement éditables et envoient les bons événements.
			</li>
		</ul>
		<br>
		<br>
		A bientôt!
		<br>
		<b>@MaximeEuziere</b>
	</div>
	<button onclick="document.getElementById('contenteditable').style.display='block';this.style.display='none'">Lire</button>
</div>


<div class=section>
	<h2>Le doctype HTML5</h2>
	<h3>juin 2013</h3>
	<div id=doctype style="display: none">
		<p>Le doctype n'est pas un élément HTML comme les autres, c'est un préambule qui sert à dire au navigateur comment il doit afficher le reste de la page.</p>
		<p>Ce préambule existe depuis HTML2 et XHTML1. Toutefois, jusqu'à l'apparition d'HTML5, les doctypes étaient de très longues chaînes impossibles à mémoriser par coeur, et pour peu qu'on fasse une faute de frappe, les navigateurs pouvaient mal le prendre, en particulier IE qui applique des règles d'affichage ancestrales (qu'on appelle aussi "mode quirks") en cas de doctype absent ou invalide.</p>
		<p>Bref: ce qu'il faut retenir, c'est que maintenant, le doctype s'écrit comme ceci: <b>&lt;!doctype html></b>, et qu'il doit être placé tout au début du document HTML. Il est suivi de l'élément racine, à savoir <b>&lt;html></b>.</p>
		</p>Oui mais comment on fait du XHTML5 alors? La réponse est simple: ça n'existe pas. Il n'y a qu'un HTML5, et il n'est ni "X" ni "strict" ni "transitional". et ça ne l'empêche pas de bien marcher, même sur les IE préhistoriques.</p>
		<hr>
		<p>Voici maintenant la liste tant attendue des trucs de ouf concernant <b>le doctype HTML5</b>:</p>
		<ul>
			<li>Le <b>doctype</b> est insensible à la casse et peut contenir plusieurs espaces avant et après le mot "html". Vous pouvez donc l'écrire <b>&lt;!DoCtYpE &nbsp; &nbsp; HtMl &nbsp; ></b> si ça vous chante.</li>
			<li>Le <b>doctype</b> HTML5 peut contenir <a href="http://www.w3.org/html/wg/drafts/html/master/syntax.html#the-doctype" target="_blank">d'autres informations</a>, mais aucune n'est utile quand on écrit son HTML à la main ou avec un IDE moderne.
			<li>
				Le <b>doctype</b> et l'élément <b>title</b> sont les deux seuls éléments obligatoires dans un document HTML5 valide.
				<br>
				Voici le plus petit valide document HTML5:
				<pre>&lt;!doctype html>
&lt;title>&lt;/title></pre>
			</li>
			<li>
				Le doctype ne peut pas être lu, ni modifié en JavaScript, mais on peut tout de même savoir si le navigateur est en mode quirks ou en mode compatibilité comme ceci:
				<pre>if(document.compatMode === 'CSS1Compat'){
	// On est pas en mode quirks!
}
if(document.compatMode === 'BackCompat'){
	// On est en mode compatibilité!
}</pre>
				<button onclick="alert(document.compatMode!=='CSS1Compat')">Est-on en mode quirks?</button>
				<button onclick="alert(document.compatMode!=='BackCompat')">Est-on en mode compatibilité?</button> (si les deux sont "false", tout va bien)
			</li>
			<li>A propos du "mode compatibilité", qui pousse IE7, IE8, IE9 et IE10 à afficher les pages Web avec le moteur de rendu de leur prédécésseur (E6, IE7, IE8 et IE9, respectivement), de nombreuses raisons font que ce mode s'active sur IE, mais le plus souvent, c'est dû au fait qu'on visionne une page HTML qui se trouve sur son PC, ou sur un réseau local. Pour éviter ce désagrément, ouvrez IE, faites "alt" pour que le menu du haut apparaisse, allez sur "outils > paramètres d'affichage de compatibilité" et décochez "Afficher les sites intranet dans Affichage de compatibilité". Faites "OK" et redémarrez IE. C'est réglé!</li>
			<li>
				Sur IE < 9, le <b>doctype</b>, du fait qu'il commence par un <b>!</b>, est considéré comme un <b>commentaire HTML</b>. En voici la preuve:
				<pre>// Récupérons le nom du premier élément HTML de cette page dans le DOM
var premier_element = document.getElementsByTagName("*")[0].tagName;</pre>
				<button onclick="alert(document.getElementsByTagName('*')[0].tagName)">Quel est le nom du premier élément du DOM?</button> ("!" sur IE < 9, "HTML" ailleurs)
				<br>
				<br>
				(Les IE < 9 sont d'ailleurs les seuls navigateurs à inclure les commentaires (sauf les commentaires conditionnels) dans <b>document.getElementsByTagName("*")</b>, comme décrit <a href="http://lea.verou.me/2009/02/20things-you-should-know-when-not-using-a-js-library/" target="_blank">ici</a>)
			</li>
			<li>
				Le <b>doctype</b> HTML5 fait apparaitre de vilaines scrollbars autour des <b>iframes</b> sur IE6, pour <a href="http://inmyexperience.com/2003/01/iframe-and-doctype-follies.html" target="_blank">d'obscures raisons</a>, alors que les doctypes d'avant HTML4 ne le faisaient pas. Le seul moyen de les faire disparaître est d'utiliser l'attribut (hélas non standard) <b>scrolling=no</b> sur vos iframes... si vous voulez supporter IE6, bien sûr, ce que je ne vous conseille pas de faire.</li>
				Démo: iframe normale<br>
				<iframe style="width: 200px; height: 40px; border: 1px solid black;"></iframe>
				<br><br>iframe sans scrollbars sur IE6<br>
				<iframe style="width: 200px; height: 40px; border: 1px solid black;" scrolling=no></iframe>
			</li>
			<li>Il y a un autre bug sur IE, y compris IE10 (et peut-être IE11, à confirmer): si votre page est en mode quirks, et qu'elle contient des <b>iframe</b> qui ont un doctype valide, ces <b>iframe</b> s'afficheront tout de même en mode quirks!
		</ul>
		<br>
			<br>
		A bientôt!
		<br>
		<b>@MaximeEuziere</b>
	</div>
	<button onclick="document.getElementById('doctype').style.display='block';this.style.display='none'">Lire</button>
</div>
  </div>
</body>
</html>