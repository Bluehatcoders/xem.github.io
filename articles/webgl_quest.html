<!doctype html>
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, user-scalable=no">
<html>
<head>
<link rel=stylesheet href="../style.css?v=4">
<title>Maxime Euzière</title>
</head>
<body class=large>

<div class="wrapper">

<header></header>

<div id=menu></div>

<main>

<div class=section id=webgl_quest>
  <h2>The quest of the 🌍🔬🕸🇬🇱🎠 (World's Smallest WebGL Playground)</h2>
  <br>
  <h3>april 2016 - november 2019</h3>
  <h4>Authors: Mathieu 'p01' Henri, Martin 'Aemkei' Kleppe, Subzey, Anders Kaare, LiterallyLara, HellMood, innovati, Bálint Csala, Frank Force, Senokay, Román Cortés</h4>
  <hr>
  <br>
  <h3>12/2019 update</h3>
  <p>We managed to remove the uniform time variable (by recompiling the program at each frame with a new value).
  <br>We also got rid of the verbose triangle generation (by rendering everything <a href="https://twitter.com/MaximeEuziere/status/1196197953897140224">on a big square point</a>). You can find more info about drawing points in <a href="webgl_guide.html">this tutorial</a>.
  <br>Our <a href="webgl_quest_2.html">raymarching / sdf</a> post has been updated accordingly.
  <br>
  <h3>01/2017 update</h3>
  <p>We made an entry for JS1k 2017 featuring all the tricks of this article, plus a nice UI and full Shadertoy compatibility. It was ranked #7! (<a href="http://js1k.com/2017-magic/demo/2645">ENTRY</a> / <a href="https://github.com/xem/MiniShadertoy/blob/gh-pages/js1k.html">COMMENTED CODE</a>).
  <br>
  <h3>04/2016: the origin</h3>
  <p>After welcoming LiterallyLara and HellMood who won JS1K 2017 with a WebGL entry, the codegolf team gave itself a nice challenge: develop the smallest possible HTML/JS boilerplate that's able to run a WebGL fragment shader, à la Shadertoy. Our starting point was <a href="//xem.github.io/MiniShadertoy">MiniShadertoy</a>, that we simplified into <a href="https://xem.github.io/MiniShadertoyLite/">MiniShadertoyLite</a>, and after weeks of intense golfing, we managed reduce the code down to 349b!
  
  <br>
  <h3>State of the art</h3>
  <p>The tiny WebGL playground is currently as short as <b>266 bytes</b>, and looks like this:
  <pre style=padding:5px><code class="lang-html">&lt;canvas id=c>&lt;svg onload='for(i in g=c.getContext`webgl`)g[i[0]+i[6]]=g[i];setInterval("with(g)A=s=>sS(S=cS(h++),`precision lowp float;void main(){float t=${NO++}.;${s};}`)|ce(S)|aS(p,S),p=cP(h=FN),A`<b>[INSERT YOUR SHADER HERE]</b>`,A`gl_Position=vec4(gl_PointSize=6e2)`,dr(lo(p),ug(p),1),dP(p)")'></code></pre>
  <p>(<a href="https://xem.github.io/webgl-guide/visualizer/#PGNhbnZhcyBpZD1jPjxzdmcgb25sb2FkPSdmb3IoaSBpbiBnPWMuZ2V0Q29udGV4dGB3ZWJnbGApZ1tpWzBdK2lbNl1dPWdbaV07d2l0aChnKXA9Y1Aoc2V0SW50ZXJ2YWwoej0+ZHIodW5pZm9ybTFmKGdmKHAsInQiKSxOTysrKSwwLDEpLEE9cz0+c1MoUz1jUyhGTisrKSxgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7dW5pZm9ybSBmbG9hdCB0O3ZvaWQgbWFpbigpeyR7c307fWApfGNlKFMpfGFTKHAsUykpKSxBYHZlYzQgcD12ZWM0KGdsX0ZyYWdDb29yZC54eS92ZWMyKDE1MCw3NSktMS4sMCwxKTtnbF9GcmFnQ29sb3I9cCtzaW4oYXRhbihwLnkscC54KSo5Likqc2luKHAqdC83MC4rOS4vZG90KHAscCkrdC83MC4pYCxBYGdsX1Bvc2l0aW9uPXZlYzQoMCwwLDAsZ2xfUG9pbnRTaXplPTNlMilgLGxvKHApLHVnKHApJz4=">DEMO</a> / <a href="https://xem.github.io/webgl-guide/visualizer/#PGNhbnZhcyBpZD0iYyIgd2lkdGg9MzAwIGhlaWdodD0zMDA+PC9jYW52YXM+CjxzY3JpcHQ+CnZhciBnbCA9IGMuZ2V0Q29udGV4dCgid2ViZ2wiKTsKdmFyIHZzaGFkZXIgPSBgCnZvaWQgbWFpbigpewogIGdsX1Bvc2l0aW9uPXZlYzQoMCwwLDAsMSk7Z2xfUG9pbnRTaXplPTMwMC4wOwp9YDsKdmFyIGZzaGFkZXIgPSBgCnByZWNpc2lvbiBsb3dwIGZsb2F0O3VuaWZvcm0gZmxvYXQgdDsKdm9pZCBtYWluKCl7CiB2ZWM0IHA9dmVjNChnbF9GcmFnQ29vcmQueHkvMTUwLi0xLiwwLiwxKTsKIGdsX0ZyYWdDb2xvcj1wK3NpbihhdGFuKHAueSxwLngpKjkuKSpzaW4ocCp0LzQwLjArOS4vZG90KHAscCkrdC80MC4pOyAvLyA8PSBlZGl0IHlvdXIgc2hhZGVyIGhlcmUKfWA7CnZhciB2cyA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTsKZ2wuc2hhZGVyU291cmNlKHZzLCB2c2hhZGVyKTsKZ2wuY29tcGlsZVNoYWRlcih2cyk7CnZhciBmcyA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpOwpnbC5zaGFkZXJTb3VyY2UoZnMsIGZzaGFkZXIpOwpnbC5jb21waWxlU2hhZGVyKGZzKTsKdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7CmdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2cyk7CmdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcyk7CmdsLmxpbmtQcm9ncmFtKHByb2dyYW0pOwpnbC51c2VQcm9ncmFtKHByb2dyYW0pOwp2YXIgZnJhbWUgPSAwOwpzZXRJbnRlcnZhbCgoKSA9PiB7CiAgZ2wudW5pZm9ybTFmKGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAidCIpLCBmcmFtZSsrKTsKICBnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywwLDEpOwp9LDE2KQo8L3NjcmlwdD4=">UNGOLFED VERSION</a>)
  
  <p>When writing your shader in this boilerplate, you have access to:
  <ul>
  <li><b>t</b>: a frame counter
  <li><b>gl_FragCoord</b>: the coordinates of the current pixel on the canvas (by default, x ∈ [0:300], y ∈ [0:150])
  </ul>
  ...and you need to set <b>gl_FragColor</b>, representing the color of each pixel.
  
  <br>
  <p><b>Tips:</b>
  <ul>
  <li>You can resize the canvas by appending the html attributes: <b style=background:#def>&lt;canvas id=c width=600 height=600></b> or in js: <b style=background:#def>c.width=c.height=600</b>
  <li>If you want to count milliseconds instead of frames by changing the way NO is incremented. Ex: <b style=background:#def>NO+=.016</b>
  <li>you can convert gl_FragCoord into clip space coordinates (where x,y ∈ [-1:1]) by prepending your shader with: <b style=background:#def>vec4 p=vec4(gl_FragCoord.xy/vec2(150,75)-1.,0,1);</b> (150 and 75 are half the canvas's width and height. If you resize it, you'll have to change them)
  <li>If you resize your canvas, you'll also need to change the rendering point's size (for example: <b style=background:#def>gl_PointSize=6e2</b>)
  </ul>
  
  <br>
  <p>Here are <a href="https://rawgit.com/literallylara/7c1f8dbe2effc415c746f3684beb8530/raw/08e31826be41cf87473a6949e0885b131328f807/Tiny%2520WebGL%2520Boilerplate.html">some gorgeous demos</a> made by LiterallyLara while we were golfing this, in less than 512b.
  <p><a href="https://rawgit.com/literallylara/7c1f8dbe2effc415c746f3684beb8530/raw/08e31826be41cf87473a6949e0885b131328f807/Tiny%2520WebGL%2520Boilerplate.html"><img src="./images/webgl/elias.jpg" width=600 style="border:1px solid"></a>
  
  <br>
  
  <p>Commented source code
  
  <div style="overflow-x:scroll"><pre style="width:1200px"><code class="lang-html">&lt;canvas id=c>
&lt;script>

// Canvas methods hashing:
// Creates tiny shortcuts for all the WebGL methods and constants we need:
// g.createProgram => g.cP
// g.shaderSource => g.sS
// g.createShader => g.cS
// g.compileShader => g.ce
// g.attachShader => g.aS
// g.linkProgram => g.lo
// g.useProgram => g.ug
// g.deleteProgram => g.dP
// g.getUniformLocation => g.gf
// g.drawArrays => g.dr
// g.NO_ERROR => g.NO (= 0)
// g.FRAGMENT_SHADER => g.FN (= 35632)
// g.VERTEX_SHADER => g.V_ (= 35633)

for(i in g=c.getContext(`webgl`)){
  g[i[0]+i[6]]=g[i];
}

setInterval(() => {             // Repeat the following code 60 times per second:
                                // In the golfed code, the function is replaced with a string: setInterval("with(g)...")
                                // Also, the second parameter of setInterval is omitted. It defaults to ~60fps on modern browsers
                                
  with(g){                      // Make g implicit (no need to use the prefix "g.")
                                // In the golfed code, the curly braces are removed
                                // This is possible because all the following statements are separated by "," instead of ";"
                                
    A = s => {                  // Declare the function A that will be used twice per frame. It creates, compiles and attaches a shader to the program
                                // In the golfed code, the curly braces are removed.
                                // This is possible because all the following statements are separated by "|" instead of ";"
                                
      sS(                       // - g.shaderSource(S = g.createShader(h++, template)) creates the shader "S" and sets its type and source code
        S = cS(h++),            //   The first time A() is called, h (the type) is equal to g.FRAGMENT_SHADER (36532), then it is incremented
                                //   The second time A() is called h is equal to g.VERTEX_SHADER (36533)
        
        `                       // This template is common to both vertex and fragment shaders:
          precision lowp float; // * Set the global float precision (lowp)
          void main(){          // * Declare the main function of the shader
            float t=${NO++}.;   // * Declare the time variable "t", increased by JS at each frame. g.NO is used because its value on load is 0
            ${s};               // * Append the code of the current shader
          }
        `
      )
      | ce(S)                   // - g.compileShader(S)
      | aS(p, S)                // - g.attachShader(p, S)
    },
    
    p = cP(                     // Create a WebGL program "p"
      h = FN                    // Set the variable "h" equal to g.FRAGMENT_SHADER. It will be used in A()
    ),
    
    A(`<b>[SHADER]</b>`),              // call A() a first time to set up the fragment shader (your code goes here)    
    A(`                         // call A() a second time to set up the vertex shader (defines the point's size: 600, and position: x = y = z = 600)
      gl_Position = vec4(gl_PointSize = 6e2)
    `),
    
    dr(                         // g.drawArrays(0,0,1) - draws a single point on the canvas (mode = g.POINTS, start = 0, count = 1)
      lo(p),                    // - g.linkProgram(p) returns "undefined", which is equivalent to "0"
      ug(p),                    // - g.useProgram(p) returns "undefined", which is equivalent to "0"
      !dP(p)                    // - g.deleteProgram(p) returns "undefined". It becomes "true" with a "!" at the beginning, which is equivalent to "1"
    )
  }
}
&lt;/script>
</code></pre></div>
  
  <br>
  
  <p><b>Golf progress</b>

  <p>Here's the <a href="https://github.com/xem/MiniShadertoyLite/blob/ab7a4b7f137745020d283a155b5210676055731a/index.html#L28-L92">clean source code of MiniShadertoyLite</a>, our model.
  
<div  style="overflow-x:scroll">
<pre style="width:3500px"><code class="lang-html"><b>// Step 1: start from MiniShadertoyLite, remove the textarea (hardcoded shader), minify, apply RegPack's webgl method hashing, replace all the constants with their numeric value</b>

&lt;body onload='for(i in g=a.getContext(`webgl`))g[i[0]+i[7]+[i[13]]]=g[i];setInterval(`g.uniform1f(g.goa(P,"T"),T++);g.da(6,0,3)`,9);with(g)P=cr(),so(S=ch(35633),`attribute vec2 P;${V="void main(){gl_"}Position=vec4(P,0,1);}`),cS(S),ah(P,S),so(S=ch(35632),`precision lowp float;uniform float T;${V}FragColor=[SHADER]}`),cS(S),ah(P,S),lg(P),ur(P),bf(B=34962,cu()),eet(T=0),vto(0,2,5120,0,0,0),ba(B,new Int8Array([-3,1,1,-3,1,1]),35044)'>&lt;canvas id=a>

<b>// Step 2: simplify `gl_Position=vec4(P,0,1)` to `gl_Position.xy=P`</b>

&lt;body onload='for(i in g=a.getContext(`webgl`))g[i[0]+i[7]+[i[13]]]=g[i];setInterval(`g.uniform1f(g.goa(P,"T"),T++);g.da(6,0,3)`,9);with(g)P=cr(),so(S=ch(35633),`attribute vec2 P;${V="void main(){gl_"}Position.xy=P;}`),cS(S),ah(P,S),so(S=ch(35632),`precision lowp float;uniform float T;${V}FragColor=[SHADER]}`),cS(S),ah(P,S),lg(P),ur(P),bf(B=34962,cu()),eet(T=0),vto(0,2,5120,0,0,0),ba(B,new Int8Array([-3,1,1,-3,1,1]),35044)'>&lt;canvas id=a>

<b>// Step 3: place the `;` in the template, reuse B at the end</b>

&lt;body onload='for(i in g=a.getContext(`webgl`))g[i[0]+i[7]+[i[13]]]=g[i];setInterval(`g.uniform1f(g.goa(P,"T"),T++);g.da(6,0,3)`,9);with(g)P=cr(),so(S=ch(35633),`attribute vec2 P${V=";void main(){gl_"}Position.xy=P;}`),cS(S),ah(P,S),so(S=ch(35632),`precision lowp float;uniform float T${V}FragColor=[SHADER]}`),cS(S),ah(P,S),lg(P),ur(P),bf(B=34962,cu()),eet(T=0),vto(0,2,5120,0,0,0),ba(B,new Int8Array([-3,1,1,-3,1,1]),B+82)'>&lt;canvas id=a>

<b>// Step 4: `with(g)` including the setInterval, arrow function inside setInterval, `int8array.of()`</b>

&lt;body onload='for(i in g=a.getContext(`webgl`))g[i[0]+i[7]+[i[13]]]=g[i];with(g)setInterval(x=>uniform1f(goa(P,"T"),T++)+da(6,0,3),9),P=cr(),so(S=ch(35633),`attribute vec4 P${V=";varying lowp vec4 c;void main(){gl_"}Position=c=P;}`),(A=x=>cS(S)+ah(P,S))(),so(S=ch(35632),`uniform lowp float T${V}FragColor=[SHADER]}`),A(),lg(P),ur(P),bf(B=34962,cu()),eet(T=0),vto(0,2,5120,0,0,0),ba(B,Int8Array.of(-3,1,1,-3,1,1),B+82)'>&lt;canvas id=a>

<b>// Step 5: move some reused code inside the `A()` function, and reuse B better</b>

&lt;body onload='for(i in g=a.getContext(`webgl`))g[i[0]+i[7]+[i[13]]]=g[i];with(g)setInterval(x=>uniform1f(goa(P,"T"),T++)+da(6,0,3),9),P=cr(),B=35633,(A=s=>so(S=ch(B--),s)+cS(S)+ah(P,S))(`attribute vec4 P${V=";varying lowp vec4 c;void main(){gl_"}Position=c=P;}`),A(`uniform lowp float T${V}FragColor=[SHADER]}`),lg(P),ur(P),bf(B=34962,cu()),eet(T=0),vto(0,2,5120,0,0,0),ba(B,Int8Array.of(-3,1,1,-3,1,1),B+82)'>&lt;canvas id=a>

<b>// Step 6: replace "body onload=..." with "svg onload=..."</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext(`webgl`))g[i[0]+i[7]+[i[13]]]=g[i];with(g)setInterval(x=>uniform1f(goa(P,"T"),T++)+da(6,0,3),9),P=cr(),B=35633,(A=s=>so(S=ch(B--),s)+cS(S)+ah(P,S))(`attribute vec4 P${V=";varying lowp vec4 c;void main(){gl_"}Position=c=P;}`),A(`uniform lowp float T${V}FragColor=[SHADER]}`),lg(P),ur(P),bf(B=34962,cu()),eet(T=0),vto(0,2,5120,0,0,0),ba(B,Int8Array.of(-3,1,1,-3,1,1),B+82)'>

<b>// Step 7: use a simpler hashing (`g[i[0]+i[6]]` instead of `g[i[0]+i[7]+[i[13]]]`)</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext(`webgl`))g[i[0]+i[6]]=g[i];with(g)setInterval(x=>uniform1f(gf(P,"T"),T++)+dr(6,0,3),9),P=cP(),B=35633,(A=s=>sS(S=cS(B--),s)+ce(S)+aS(P,S))(`attribute vec4 P${V=";varying lowp vec4 c;void main(){gl_"}Position=c=P;}`),A(`uniform lowp float T${V}FragColor=[SHADER]}`),lo(P),ug(P),bf(B=34962,cB()),eV(T=0),vA(0,2,5120,0,0,0),bD(B,Int8Array.of(-3,1,1,-3,1,1),B+82)'>

<b>// Step 8: replace the first usages of `B` (36532, 36533) with hashed properties (`g.FN` and `g.FN+1`, simplified to `g.FN++` called twice)</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext(`webgl`))g[i[0]+i[6]]=g[i];with(g)setInterval(x=>uniform1f(gf(P,"T"),T++)+dr(6,0,3),9),P=cP(),(A=s=>sS(S=cS(FN++),s)+ce(S)+aS(P,S))(`uniform lowp float T${V=";varying lowp vec4 c;void main(){gl_"}FragColor=[SHADER]}`),A(`attribute vec4 P${V}Position=c=P;}`),lo(P),ug(P),bf(B=34962,cB()),eV(T=0),vA(0,2,5120,0,0,0),bD(B,Int8Array.of(-3,1,1,-3,1,1),B+82)'>

<b>// Step 9: replace `T` with `g.NO`, which is already set to 0</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext(`webgl`))g[i[0]+i[6]]=g[i];with(g)setInterval(x=>uniform1f(gf(P,"T"),NO++)+dr(6,0,3),9),P=cP(),(A=s=>sS(S=cS(FN++),s)+ce(S)+aS(P,S))(`uniform lowp float T${V=";varying lowp vec4 c;void main(){gl_"}FragColor=[SHADER]}`),A(`attribute vec4 P${V}Position=c=P;}`),lo(P),ug(P),bf(B=34962,cB()),eV(0),vA(0,2,5120,0,0,0),bD(B,Int8Array.of(-3,1,1,-3,1,1),B+82)'>

<b>// Step 10: simplify the constant `34962` with `g.ET-3`</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext(`webgl`))g[i[0]+i[6]]=g[i];with(g)setInterval(x=>uniform1f(gf(P,"T"),NO++)+dr(6,0,3),9),P=cP(),(A=s=>sS(S=cS(FN++),s)+ce(S)+aS(P,S))(`uniform lowp float T${V=";varying lowp vec4 c;void main(){gl_"}FragColor=[SHADER]}`),A(`attribute vec4 P${V}Position=c=P;}`),lo(P),ug(P),bf(B=ET-3,cB()),eV(0),vA(0,2,5120,0,0,0),bD(B,Int8Array.of(-3,1,1,-3,1,1),B+82)'>

<b>// Step 11: Subzey joins the game... remove `getContext` parenthesis, replace the second param of `g.dr` (0) with the result of the neighbour function `uniform1f()`. Renamem c into p and T to t</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext`webgl`)g[i[0]+i[6]]=g[i];with(g)setInterval(x=>dr(6,uniform1f(gf(P,"t"),NO++),3),P=cP(),(A=s=>sS(S=cS(FN++),s)+ce(S)+aS(P,S))(`uniform lowp float t${V=";varying lowp vec4 p;void main(){gl_"}FragColor=[SHADER]}`),A(`attribute vec4 P${V}Position=p=P;}`),lo(P),ug(P),bf(B=ET-3,cB()),eV(0),vA(0,2,5120,0,0,0),bD(B,Int8Array.of(-3,1,1,-3,1,1),B+82))'>

<b>// Step 12: get rid of some more zeros</b>
&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext`webgl`)g[i[0]+i[6]]=g[i];with(g)setInterval(x=>dr(6,uniform1f(gf(P,"t"),NO++),3),P=cP(),(A=s=>sS(S=cS(FN++),s)+ce(S)+aS(P,S))(`uniform lowp float t${V=";varying lowp vec4 p;void main(){gl_"}FragColor=[SHADER]}`),vA(A(`attribute vec4 P${V}Position=p=P;}`),2,5120,lo(P),ug(P),eV(bf(B=ET-3,cB()))),bD(B,Int8Array.of(-3,1,1,-3,1,1),B+82))'>

<b>// Step 13: move `A` declaration into `cP()`</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext`webgl`)g[i[0]+i[6]]=g[i];with(g)setInterval(x=>dr(6,uniform1f(gf(P,"t"),NO++),3),P=cP(A=s=>sS(S=cS(FN++),s)+ce(S)+aS(P,S)),A(`uniform lowp float t${V=";varying lowp vec4 p;void main(){gl_"}FragColor=[SHADER]}`),vA(A(`attribute vec4 P${V}Position=p=P;}`),2,5120,lo(P),ug(P),eV(bf(B=ET-3,cB()))),bD(B,Int8Array.of(-3,1,1,-3,1,1),B+82))'>

<b>// Step 14: move `vA`, replace the ones in `Int8Array.of()` with neighbor functions</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext`webgl`)g[i[0]+i[6]]=g[i];with(g)setInterval(x=>dr(6,uniform1f(gf(P,"t"),NO++),3),!vA(P=cP(A=s=>sS(S=cS(FN++),s)+ce(S)+aS(P,S)),2,5120,A(`uniform lowp float t${V=";varying lowp vec4 p;void main(){gl_"}FragColor=[SHADER]}`),eV(bf(B=ET-3,cB())),bD(B,Int8Array.of(-3,1,!A(`attribute vec4 P${V}Position=p=P;}`),-3,!lo(P),!ug(P)),B+82)))'>

<b>// Step 15: move `vA(P=cP(...))` around the `setInterval`</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext`webgl`)g[i[0]+i[6]]=g[i];with(g)vA(P=cP(setInterval(x=>dr(6,uniform1f(gf(P,"t"),NO++),3),A=s=>sS(S=cS(FN++),s)+ce(S)+aS(P,S))),2,5120,A(`uniform lowp float t${V=";varying lowp vec4 p;void main(){gl_"}FragColor=[SHADER]}`),eV(bf(B=ET-3,cB())),bD(B,Int8Array.of(-3,1,!A(`attribute vec4 P${V}Position=p=P;}`),-3,!lo(P),!ug(P)),B+82))'>

<b>// Step 16: change the Int8Array's vertices to `3,-1,-1,3,-1,-1` and use `~` to turn `null` into `-1`</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext`webgl`)g[i[0]+i[6]]=g[i];with(g)vA(P=cP(setInterval(x=>dr(6,uniform1f(gf(P,"t"),NO++),3),A=s=>sS(S=cS(FN++),s)+ce(S)+aS(P,S))),2,5120,A(`uniform lowp float t${V=";varying lowp vec4 p;void main(){gl_"}FragColor=[SHADER]}`),eV(bf(B=ET-3,cB())),bD(B,Int8Array.of(3,-1,~A(`attribute vec4 P${V}Position=p=P;}`),3,~lo(P),~ug(P)),B+82))'>

<b>// Step 17: Make `A()` always return `-1`</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext`webgl`)g[i[0]+i[6]]=g[i];with(g)vA(P=cP(setInterval(x=>dr(6,uniform1f(gf(P,"t"),NO++),3),A=s=>sS(S=cS(FN++),s)|ce(S)|~aS(P,S))),2,5120,0,eV(bf(B=ET-3,cB())),bD(B,Int8Array.of(3,A(`uniform lowp float t${V=";varying lowp vec4 p;void main(){gl_"}FragColor=[SHADER]}`),A(`attribute vec4 P${V}Position=p=P;}`),3,~lo(P),~ug(P)),B+82))'>

<b>// Step 18: change the shape of the triangle, using the return value of `setInterval` (usually between 1 and 127) as first param of `Int8Array`</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext`webgl`)g[i[0]+i[6]]=g[i];with(g)vA(P=cP(),2,5120,bD(B=ET-3,Int8Array.of(B,setInterval(x=>dr(6,uniform1f(gf(P,"t"),NO++),3),A=s=>sS(S=cS(FN++),s)|ce(S)|aS(P,S)),!A(`uniform lowp float t${V=";varying lowp vec4 p;void main(){gl_"}FragColor=[SHADER]}`),B,!eV(bf(B,cB())),!A(`attribute vec4 P${V}Position=p=P;}`)),B+82),lo(P),ug(P))'>

<b>// Step 19: introduce C and T as attributes, set `t.x=T.x`, and use `vA` (vertexAttrib1f) instead of `uniform1f`</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext`webgl`)g[i[0]+i[6]]=g[i];with(g)vA(P=cP(),2,5120,bD(B=ET-3,Int8Array.of(B,setInterval(x=>dr(6,vertexAttrib1f(1,NO++),3),A=s=>sS(S=cS(FN++),s)|ce(S)|aS(P,S)),!A(`${V="varying lowp vec4 p,t;void main(){gl_"}FragColor=[SHADER]}`),B,!eV(bf(B,cB())),!A(`attribute vec4 P,T;${V}Position=p=P;t.x=T.x;}`)),B+82),lo(P),ug(P))'>

<b>// Step 20: Set `t=T` directly</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext`webgl`)g[i[0]+i[6]]=g[i];with(g)vA(P=cP(),2,5120,bD(B=ET-3,Int8Array.of(B,setInterval(x=>dr(6,vertexAttrib1f(1,NO++),3),A=s=>sS(S=cS(FN++),s)|ce(S)|aS(P,S)),!A(`${V="varying lowp vec4 p,t;void main(){gl_"}FragColor=[SHADER]}`),B,!eV(bf(B,cB())),!A(`attribute vec4 P,T;${V}Position=p=P;t=T;}`)),B+82),lo(P),ug(P))'>

<b>// Step 21: Set 5th parameter of vA (i.e. `vertexAttribPointer`), stride, to 1, to  make the coordinate pairs overlap: `int8Array.of(x1 = 1, y1 = x2 = -3, y2 = x3 = 1, y3 = 1)`. Also, the setTimeout is moved into `cP` (i.e. `createProgram`)</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext`webgl`)g[i[0]+i[6]]=g[i];with(g)vA(P=cP(setInterval(x=>dr(6,vertexAttrib1f(1,NO++),3),A=s=>sS(S=cS(FN++),s)|ce(S)|aS(P,S))),2,5120,bD(B=ET-3,Int8Array.of(!A(`${V="varying lowp vec4 p,t;void main(){gl_"}FragColor=[SHADER]}`),B,!eV(bf(B,cB())),!A(`attribute vec4 P,T;${V}Position=p=P;t=T;}`)),B+82),!lo(P),ug(P))'>

<b>// Step 22: Make `A` return 1 in order to avoid calling `!A()` with a `!` twice</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext`webgl`)g[i[0]+i[6]]=g[i];with(g)vA(P=cP(setInterval(x=>dr(6,vertexAttrib1f(1,NO++),3),A=s=>sS(S=cS(FN++),s)|ce(S)|!aS(P,S))),2,5120,bD(B=ET-3,Int8Array.of(A(`${V="varying lowp vec4 p,t;void main(){gl_"}FragColor=[SHADER]}`),B,!eV(bf(B,cB())),A(`attribute vec4 P,T;${V}Position=p=P;t=T;}`)),B+82),!lo(P),ug(P))'>

<b>// Step 23: Rearrange `Int8Array.of()` arguments to place `!eV()` first, and move `V` declaration into `cb()`</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext`webgl`)g[i[0]+i[6]]=g[i];with(g)vA(P=cP(setInterval(x=>dr(6,vertexAttrib1f(1,NO++),3),A=s=>sS(S=cS(FN++),s)|ce(S)|!aS(P,S))),2,5120,bD(B=ET-3,Int8Array.of(!eV(bf(B,cB(V="varying lowp vec4 p,t;void main(){gl_"))),B,A(V+`FragColor=[SHADER]}`),A(`attribute vec4 P,T;${V}Position=p=P;t=T;}`)),B+82),!lo(P),ug(P))'>

<b>// Step 24: Use the svg's id (which is an empty string by default)</b>

&lt;canvas id=a>&lt;svg onload='for(i in g=a.getContext`webgl`)g[i[0]+i[6]]=g[i];with(g)vA(P=cP(setInterval(x=>dr(6,vertexAttrib1f(1,NO++),3),A=s=>sS(S=cS(FN++),id+"varying lowp vec4 p,t;void main(){gl_"+s)|ce(S)|!aS(P,S))),2,5120,bD(B=ET-3,Int8Array.of(A`FragColor=[SHADER]}`,B,!eV(bf(B,cB(id="attribute vec4 P,T;"))),A`Position=p=P;t=T;}`),B+82),!lo(P),ug(P))'>

<b>// Step 25 (11/2019): Replace the triangle with a single, huge point. No need to use a buffer object anymore! (we lose Safari compatibility here)

&lt;canvas id=c>&lt;svg onload='for(i in g=c.getContext`webgl`)g[i[0]+i[6]]=g[i];with(g)p=cP(setInterval(z=>dr(uniform1f(gf(p,"t"),NO++),0,1),A=s=>sS(S=cS(FN++),`precision lowp float;uniform float t;void main(){${s};}`)|ce(S)|aS(p,S))),A`[SHADER]`,A`gl_Position=vec4(0,0,0,gl_PointSize=3e2)`,lo(p),ug(p)'>

<b>// Step 26 (12/2019): Get rid of the zeros in gl_Position, use "vec4(6e2)" instead

&lt;canvas id=c>&lt;svg onload='for(i in g=c.getContext`webgl`)g[i[0]+i[6]]=g[i];with(g)p=cP(setInterval(z=>dr(uniform1f(gf(p,"t"),NO++),0,1),A=s=>sS(S=cS(FN++),`precision lowp float;uniform float t;void main(){${s};}`)|ce(S)|aS(p,S))),A`[SHADER]`,A`gl_Position=vec4(gl_PointSize=6e2)`,lo(p),ug(p)'>

<b>// Step 27 (12/2019): Get rid of the uniform time variable by recompiling the program at each frame. Also, replace the parameters of drawArrays (0,0,1) with "lo(),ug(p),!dp(p)"

&lt;canvas id=c>&lt;svg onload='for(i in g=c.getContext`webgl`)g[i[0]+i[6]]=g[i];with(g)A=s=>sS(S=cS(h++),`precision lowp float;void main(){float t=${NO++}.;${s};}`)|ce(S)|aS(p,S),setInterval(z=>{p=cP(h=FN),A`[SHADER]`,A`gl_Position=vec4(gl_PointSize=6e2)`,dr(lo(p),ug(p),!dP(p))})'>

<b>// Step 28 (12/2019): Use a string parameter for setInterval instead of a function

&lt;canvas id=c>&lt;svg onload='for(i in g=c.getContext`webgl`)g[i[0]+i[6]]=g[i];setInterval("with(g)A=s=>sS(S=cS(h++),`precision lowp float;void main(){float t=${NO++}.;${s};}`)|ce(S)|aS(p,S),p=cP(h=FN),A`[SHADER]`,A`gl_Position=vec4(gl_PointSize=6e2)`,dr(lo(p),ug(p),!dP(p))")'>



</code></pre></div>
<br>
<br>
<hr>
<br>
<p>Cheers!
<p><b>The Codegolf team</b>
</div>

</main>

</div>

<footer></footer>

<script src="../ui.js"></script>
<script>
header();
footer();
menu();
</script>

</body>
</html>