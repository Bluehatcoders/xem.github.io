<div class=intro>
  <p><b>code golfing</b> is a programming game in which we have to implement an algorithm with the shortest possible code.</p>
  <p>Many <a href=//golf.shinh.org/ target=_blank>competitions</a> exist to create JavaScript demos in less than <a href=//140byt.es target=_blank>140 characters</a>, <a href=//js1k.com target=_blank>1kb</a>, <a href=//js13kgames.com/ target=_blank>13kb</a>, <a href="http://www.pouet.net/prodlist.php?type%5B%5D=32b&type%5B%5D=64b&type%5B%5D=128b&type%5B%5D=256b&type%5B%5D=512b&type%5B%5D=1k&type%5B%5D=4k&type%5B%5D=8k&type%5B%5D=16k&type%5B%5D=32k&type%5B%5D=40k&type%5B%5D=64k&type%5B%5D=80k&type%5B%5D=96k&type%5B%5D=100k&type%5B%5D=128k&type%5B%5D=256k&type%5B%5D=artpack&type%5B%5D=bbstro&type%5B%5D=cracktro&type%5B%5D=demo&type%5B%5D=demopack&type%5B%5D=demotool&type%5B%5D=dentro&type%5B%5D=diskmag&type%5B%5D=fastdemo&type%5B%5D=game&type%5B%5D=intro&type%5B%5D=invitation&type%5B%5D=liveact&type%5B%5D=musicdisk&type%5B%5D=procedural+graphics&type%5B%5D=report&type%5B%5D=slideshow&type%5B%5D=votedisk&type%5B%5D=wild&platform%5B%5D=JavaScript&page=1" target=_blank>etc.</a></p>
  <p>Many developers have websites dedicated to JS code golfing: <a href=//aem1k.com/ target=_blank>aem1k</a>, <a href=://www.p01.org/releases/ target=_blank>p01</a>, etc.</p>
  <p>This page gathers my first experiments.</p>
</div>

<div class=section>
	<h2>How many JavaScript code can we fit in 140 characters?</h2>
	<h3>november 2013</h3>
  <p>The answer is: 190 characters!</p>
  <p>On <a href=//140byt.es target=_blank>140byt.es</a>, the goal is to write JavaScript functions that fit in a tweet, i.e. in 140 characters.</p>
  <p>Until now, these functions were always written in "clear" ASCII characters. But a tweet can contain 140 Unicode characters, including the "astral" ones, encoded on 4 bytes.</p>
  <p>So I had the idea to use this encoding (UTF-16) to compress a long JavaScript code, and insert this encoded string in a JavaScript expression able to decode and execute it, while respecting the 140 chars limitation.</p>
  <p>Here's the binary representation of an astral UTF-16 character. It is composed of two 16-bit halves (or "surrogates"), in which the first 6 bits are fixed. The last 10 bits (shown as "x" here) can take any value.</p>
  <pre>110110xx xxxxxxxx  110111xx xxxxxxxx</pre>
  <br>
  <p>Here's the binary representation of the string "ABCD" (in ASCII). Each character is encoded in 1 byte.<br>(In reality, 7 bits are enough to encode an ASCII character, but in modern charsets, the 8th bit is let at 0).</p>
  <pre>01000001 01000010 01000011 01000100</pre>
  <br>
  <p>So the idea is to use only astral UTF-16 characters and store an ASCII character at the end of each surrogate.<br>Here's the string "ABCD" stored in 2 UTF-16 characters (2 chars in one: that's a compression ratio of 50%!):</p>
  <pre>11011000 01000001 11011100 01000010  11011000 01000011 11011100 01000100 ==> 𠑂𠱄
         |--A---|          |--B---|           |--C---|          |--D---|    (ABCD encoded)</pre>
  <br>
  <p>Here's an encoder (129 bytes long) that makes this compression:</p>
  <pre>z=function(b,c,a,f,e){c="";f=String.fromCharCode;for(a=0;190>a;a+=2)c+=f(55296+b[e="charCodeAt"](a))+f(56320+b[e](a+1));return c}</pre>
  <button onclick="source_encoder190.style.display='block';this.style.display='none'">See source code</button>
  <pre id=source_encoder190 style="display: none">/**
* @param b: the input string (in ASCII)
* @param c, a, f: placeholders
*/
z = function(b, c, a, f){
    
  // Return string
  c="";
  
  // Shortcut for "String.fromCherCode"
  f = String.fromCharCode;
  
  // Loop on all the ASCII characters
  for(a = 0; 190 > a; a += 2)
  
    // Append an UTF-16 (two surrogates) to the return string
    c += f(0xD800 + b.charCodeAt(a)) + f(0xDC00 + b.charCodeAt(a + 1));
  
  // Return
  return c
}</pre>
  <script>compressAscii190=function(b,c,a){c="";if(b.length%2)b+=" ";f=String.fromCharCode;for(a=0;b.length>a;a+=2)c+=f(55296+b[e="charCodeAt"](a))+f(56320+b[e](a+1));return c}</script>
  <br>
  <p>And here is the expression decoding and executing the original JavaScript code (thanks to <a href=//twitter.com/subzey target=_blank>@subzey</a> for his help):</p>
  <pre>// replace "𠑂𠱄" with your encoded string
eval(unescape(escape("𠑂𠱄").replace(/uD./g,'')))</pre>
  <button onclick="source_decoder190.style.display='block';this.style.display='none'">See the source code</button>
  <pre id=source_decoder190 style="display: none">// First, we need to know how JavaScript handles escaped characters:
// ASCII characters are escaped as: %XX (XX is an hexadecimal value)
// UTF-16 surrogates are escaped as: %uYYXX (YYXX is an hexadecimal value, XX is the last byte)
// The escape() function does this, unescape() does the opposite.

// Encoded string
var encoded = "𠑂𠱄";

// Escape it
var escaped = escape(encoded); // --> "%uD841%uDC42%uD843%uDC44"

// Remove the 3 characters after each "%" ("uYY")
var replaced = escaped.replace(/uD./g,''); // --> "%41%42%43%44"

// Unescape it
var unescaped = unescape(replaced); // --> "ABCD" (the decoded string)

// Eval
eval(unescaped); // Tries to execute the decoded string.
  </pre>
  <br>
  <p>This decoder-executer is only 45 bytes long. So we can execute <b>190</b> ((140 - 45) x 2) JS characters in a single tweet.</p>
  <br>
  <hr>
  <br>
  <p><b>Demo:</b></p>
  JavaScript code:
  <br>
  <br>
  <textarea rows=3 id=compress>alert("This script is one hindred and ninety charecters long and sadly doesn't fit in a tweet... but if we compress is in one hundred and forty unicode characters, it's finally possible !");</textarea>
  <br>
  <script>longueur_js = 0;</script>
  <button onclick="alert(compress.innerHTML.length + ' characters')">1: Count (ASCII)</button> &nbsp; > &nbsp; 
  <button onclick="eval(compress.innerHTML)">2: Execute</button> &nbsp; > &nbsp; 
  <button onclick="longueur_js=compress.innerHTML.length;compress.innerHTML='eval(unescape(escape(\''+compressAscii190(compress.innerHTML)+'\').replace(/uD./g,\'\')))'">3: Compress</button> &nbsp; > &nbsp; 
  <button onclick="alert((Math.ceil(longueur_js/2)+45) + ' characters')">4: Count (UTF-16)</button> &nbsp; > &nbsp; 
  <button onclick="eval(compress.innerHTML)">5: Execute</button>
</div>

<div class=section>
	<h2>Snail</h2>
	<h3>october 2013</h3>
	<p>A snail matrix generator in 133 bytes</p>
	<pre>s=function(e,c,d,b,f,h,g){c=[[]];d=1;b=h=0;for(f=-1;e;e--){for(g=1;g<2*e;g++)g>e?b+=d:f+=d,c[b]||(c[b]=[]),c[b][f]=++h;d=-d}return c}</pre>
  <button onclick="source_escargot.style.display='block';this.style.display='none'">See the source code</button>
  <br>
  <pre id=source_escargot style="display:none">/**
* Snail
* @param n: the size of the matrix (n*n)
* @return: a 2D array with integers
*/

s = function(n,a,d,x,y,c,i){

  // a is the result matrix
  a = [[]];
  
  // d is the direction: right, bottom = 1; left, top = -1
  d = 1;
  
  // c is the counter value.
  c = 0;
  
  // x and y are the coordinates of the number in the matrix
  x = 0;
  y = -1;

  // Loop while n decrements
  for(; n; n--){

    // The two following loops are merged in the minified code:
    
    // fill n columns
    for(i = 0; i < n; i++){
      
      y += d;
      a[x][y] = ++c;
    }
    
    // fill n-1 lines 
    for(i = 0; i < n - 1; i++){
      
      x += d;
      if(!a[x]){
        a[x] = [];
      }
      a[x][y] = ++c;
    }

    // change direction
    d = -d;
  }
  
  return a;
}</pre>
  <br>
  <b>Demo</b>:
  <br>
  Size: <input id=taille_escargot value=8 size=2> <button id=button_escargot>Generate</button>
  <script>
    snail=function(e,c,d,b,f,h,g){c=[[]];d=1;b=h=0;for(f=-1;e;e--){for(g=1;g<2*e;g++)g>e?b+=d:f+=d,c[b]||(c[b]=[]),c[b][f]=++h;d=-d}return c}
    button_escargot.onclick = function(){
      var size = parseInt(taille_escargot.value);
      if(size > 0){
        demo_escargot.style.display = "block";
        var matrix = snail(size);
        var html = "<table style='width:auto;table-layout:fixed;background:#fff' border=rules>";
        var i, j;
        for(i = 0; i < size; i++){
          html += "<tr>";
          for(j = 0; j < size; j++){
            html += "<td style='padding:5px;text-align:center'>" + matrix[i][j] + "</td>";
          }
          html += "</tr>";
        }
        html += "</table>";
        demo_escargot.innerHTML = html;
      }
    }
  </script>
  <div class=demo id=demo_escargot style="display:none"></div>
</div>

<div class=section>
	<h2>Keys pressed</h2>
	<h3>september 2013</h3>
	<p>A way to know at any moment if a key is being pressed, in just 58 bytes.</p>
	<pre>k={};onkeydown=onkeyup=function(e){k[e=e.keyCode]=!k[e]}</pre>
	<p>
    To use it, all you have to do is choosing "n" - a keycode (<a href=//whatthekeycode.com target=_blank>for example here</a>) and test k[n]. This is true when the corresponding key is pressed, and false when it's not pressed anymore.
    <br>
    (If it has never been pressed, k[n] will be undefined, which is considered false in a test.)
    <br>
    <button onclick="source_touches_enfoncees.style.display='block';this.style.display='none'">See the source code</button>
  <br>
  <pre id=source_touches_enfoncees style="display:none">// Initialize the global k (the array representing the keys currently pressed).
// Also works with k = [].
k = {};

// Add two event handlers to the window object:
// window.onkeydown and window.onkeyup.
// They don't need the window prefix (it's implicit)
// And they both get the same callback function
onkeydown = onkeyup = function(e){

  // The two following lines are merged in the minified code:

  // e is the event handler. let's replace it with the e.keyCode attribute
  e = e.keyCode;
  
  // Invert the value of k[e]:
  // undefined => true
  // true => false
  // false => true
  k[e] = ! k[e];

}</pre>
  <br>
  <b>Demo:</b> Here is the state of k in real time. Press any key to make it change.
    <script>
      k=[];onkeydown=onkeyup=function(e){k[e=e.keyCode]=!k[e];demo_touches_enfoncees.innerHTML="k = ["+k+"]"}
    </script>
    <div class=demo><pre id=demo_touches_enfoncees>k = [ ]</pre></div>
  </p>
</div>

<div class=section>
	<h2>MiniGameOfLife</h2>
	<h3>september 2013</h3>
	<p>A Game of Life simulator in just 130 bytes.</p>
  <pre>g=function(f,c,g,d,e,b,h){g=[];e=[c+1,c,c-1,1];for(b=c*c;b--;g[b]=3==d||f[b]&&2==d,d=0)for(h in e)d+=f[b+e[h]]+f[b-e[h]];return g}</pre>
  <button onclick="source_miniGameOfLife.style.display='block';this.style.display='none'">See the source code</button>
  <br>
  <pre id=source_miniGameOfLife style="display:none">// @param s: current state of the grid
// @param d: size of the grid (d*d)
// @param n: placeholder
// @param k: placeholder
// @param m: placeholder
// @param i: placeholder
// @param j: placeholder
g = function(s, d, n, k, m, i, j){
  for(
    n = [],                           // Initialize next state
    m = [d + 1, d, d - 1, 1],         // Initialize a list of the neighbours offsets
    i = d * d;                        // For each cell
    i--;
    n[i] = k == 3 || s[i] && k == 2,  // Set next state (live if it has 3 neighbours or lives and has 2 neighbours)
    k = 0                             // Reset the count of living neighbours
  )
  for(j in m)                         // for each neighbour offset
    k += s[i + m[j]] + s[i - m[j]]    // count the living neighbours (at positions -offset and +offset)
  return(n)                           // return the next state
}</pre>
  <br>
	<b>Demo:</b> <a href=//xem.github.io/miniGameOfLife target=_blank>http://xem.github.io/miniGameOfLife</a>
</div>

<div class=section>
	<h2>MiniMinifier</h2>
	<h3>march to september 2013</h3>
	<p>A CSS code minifier in just 73 bytes. (removes all the comments and unnecessary spaces)</p>
  <pre>c.replace(/^\s|\s$|\/\*[^]*?\*\/|\s*;*([^\:\w.#'"\s*-])\s*|(:) /g,'$1$2')</pre>
  <p>There's also a more complete version, in 348 bytes (removes the useless zeros, the useless units, compresses RGB and hexadécimal colors, and handles old IE)</p>
  <pre>c.replace(/(\/\*[^]*?\*\/|\s)+/g,' ').replace(/([^#\d\w\(._'"-])((0)[a-z%]+|0(\.))|^ | $|[ ;]*([^\:\w.#)'" *-]) *| (\))|(:) */gi,'$1$3$4$5$6$7').replace(/rgb\((\d+),(\d+),(\d+)\)|#[a-f0-9]{6}/gi,function(h,a,b,c,i,p){if(c){h='#';p=[a,b,c];for(i in p)h+=('0'+parseInt(p[i]).toString(16)).slice(-2)}p=h[2]+h[4]+h[6];return p==h[1]+h[3]+h[5]?'#'+p:h})</pre>
	<br>
  <b>Demo:</b> <a href=//xem.github.io/miniMinifier target=_blank>http://xem.github.io/miniMinifier</a>
</div>

<div class=section>
	<h2>MiniCodeEditor</h2>
	<h3>march 2013</h3>
	<p>A HTML/CSS/JS sandbox engine (like codepen or jsfiddle) in just 130 caractères.<br>It updates an iframe with HTML, CSS and JS code passed in parameter.</p>
  <pre>function u(h,c,j,r){r.src="";r=r.contentWindow.document;r.write(h.value+"&lt;script>"+j.value+"&lt;\/script>&lt;style>"+c.value);r.close()}</pre>
  <button onclick="source_miniCodeEditor.style.display='block';this.style.display='none'">See the source code</button>
  <br>
  <pre id=source_miniCodeEditor style="display:none">// @param h: HTML code
// @param c: css code
// @param j: JS code
// @param r: rendering iframe
function u(h,c,j,r){
  
  // Reset the iframe
  r.src = "";
  
  // Access to the document of the iframe
  r = r.contentWindow.document;
  
  // Write in the iframe's body: the HTML, the JS in a &lt;script> tag, and the CSS in a &lt;style> tag (which is automatically closed)
  r.write(h.value + "&lt;script>" + j.value+"&lt;\/script>&lt;style>" + c.value);
  
  // Stop writing in the iframe (this stops the iframe's loading).
  r.close();
}</pre>
	<b>GitHub page:</b> <a href=//github.com/xem/miniCodeEditor target=_blank>http://github.com/xem/miniCodeEditor</a>
  <br>
	<b>Demo:</b> <a href=//xem.github.io/miniCodeEditor target=_blank>http://xem.github.io/miniCodeEditor</a>
</div>

<div class=section>
	<h2>Binary operations</h2>
	<h3>september 2012</h3>
	<p>
		Binary operations in JavaScript are a trap. I wrote a wtfjs post about this. (<a href="http://wtfjs.com/2012/09/19/Hexadecimal-weirdness" target=_blank>link</a>)
		<br>
    So I wrote a 137 bytes lib allowing to do "left shifts", "right shifts", and extracting some bits from a number, safely.
    <pre>M=Math;function l(a,b){return a*M.pow(2,b)}function r(a,b){return M.floor(a/M.pow(2,b))}function b(a,b,c){return r(a,b)&M.pow(2,c-b+1)-1}</pre>
    <button onclick="source_binaire.style.display='block';this.style.display='none'">See the source code</button>
  <br>
  <pre id=source_binaire style="display:none">// M is a shortcut for Math
M = Math;

// Left shift
// a << b is equivalent to a * (2 ^ b)
function l(a,b){
  return a * M.pow(2, b);
}

// Right shift
// a >> b is equivalent to a / (2 ^ b)
function r(a,b){
  return M.floor(a / M.pow(2, b));
}

// Bit extraction
// returns a's bits from b to c
// i.e. the last (c - b + 1) bits of (a >> b)
function b(a,b,c){
  return r(a,b) & M.pow(2, c - b + 1) - 1;
}</pre>
	</p>
</div>